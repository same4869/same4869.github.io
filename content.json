[{"title":"手撸Android-Nexus私有Maven仓库GOGOGO","date":"2019-03-21T16:00:00.000Z","path":"2019/03/22/手撸Android-Nexus私有Maven仓库GOGOGO/","text":"我们在做Android SDK的时候，总是以jar或者aar的方式让业务方依赖，在这条流水线建立起来的时候，手动去把依赖包丢给业务方显然不是正确的打开方式，而作为公司层面，上传到jcenter又会顾忌到安全的敏感问题，于是就有了私有maven仓库的出现，能够很好的解决以上问题，本文描述就是一个建立私有maven的过程，工具准备好了，总会有用到的时候。 1.远程仓库 一图胜千言，不过还是描述下，一般来说仓库分为本地的和远程的。 本地的没啥好说的，本地硬盘的一个路径，或者放在libs文件夹下来手动集成，某种程度上都算。 远程的又分为中央仓库和私库，中央仓库比较出名的是 JCenter 和 Maven Centra，全世界开源的库都可以往上面传，谁也都可以去依赖到。虽然开源是提倡的，但并适用于任何场景，比如公司的核心依赖库，在这种情况下，在公司的内网才能访问的服务器上部署Nexus私库的场景就应运而生了。 2.准备搭建首先是需要JDK1.8以上的JAVA环境，这个自备一下。 Nexus的2.X和3.X的版本感觉差了不少，本文使用的是最新的3.X的，下载官方网站是https://www.sonatype.com/download-oss-sonatype，可以根据自己的平台选择，这里使用的是MACOS环境，远程服务器测试是使用了阿里云的centos7.x。 下载后解压大概目录如下图所示 直接运行bin目录下面的nexus就行了，linux和macos的小伙伴直接运行 ./nexus run就行了（貌似也可以用./nexus start和./nexus stop配套指令来开启和关闭） 3.初试牛刀顺利运行起来了的话就可以看效果了，默认的端口是8081，当然可以在对应的配置文件里面去修改默认端口号，如果是本地起的服务，可以直接在浏览器里输入http://localhost:8081/，效果如下 这个服务运行起来大概需要几百兆的空闲内存，不然会跑不起来（第一次说需要400多M，第二次800多M）。 默认是没登录的，Nexus 提供了一个完全访问权限的管理用户。 用户名是 admin，密码是admin123。 左边切换到browser选项可以到仓库界面，如图 注意 Type 列，展示了 Nexus 的仓库分类： proxy（远程代理仓库）这种类型的仓库，可以设置一个远程仓库的链接。当用户向 proxy 类型仓库请求下载一个依赖构件时，就会先在自己的库里查找，如果找不到的话，就会从设置的远程仓库下载到自己的库里，然后返回给用户，相当于起到一个中转的作用。 例如 maven-central 用来存储从 Maven 中央仓库下载过的构件。 group （聚合仓库）在 Maven 里没有这个概念，是 Nexus 特有的。目的是将多个仓库聚合，对用户暴露统一的地址，这样用户就不需要配置多个地址，只要统一配置 group 的地址就可以了。group 仓库的聚合成员可以在仓库设置中添加和移除。 例如 maven-public 是一个 group 类型的仓库，通过引用这个地址，可以访问组内成员仓库的所有构件。 hosted（宿主仓库）我们自己的构件，上传的就是这样的仓库。目前 maven-releases 和 maven-snapshots 是 hosted 类型的仓库。我们可以上传到这两个仓库，也可以自己创建 hosted 仓库。 4.Android工程上传到Nexus私库现在本地的私库已经跑起来了，接下来开始配置Android工程,看看要怎么上传到私库了。 首先我们来创建一个Android工程，是需要打包成aar上传到私服的，所以这个工程必须是library，也就是在build.gradle里配置成apply plugin: &#39;com.android.library&#39;。 然后需要在这个library工程的模块内的gradle中配置一些task，为了方便可以单独抽一个文件出来，叫做nexus.gradle,放在根目录，内容如下： apply plugin: &#39;maven&#39; version=LIB_VERSION def nexusRepositoryUrl = NEXUS_RELEASES if (!LIB_IS_RELEASE.toBoolean()){ version = &quot;${version}-SNAPSHOT&quot; nexusRepositoryUrl = NEXUS_SNAPSHOTS } task sourcesJar(type: Jar) { classifier = &#39;sources&#39; from android.sourceSets.main.java.sourceFiles } task javadoc(type: Javadoc) { source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) classpath += configurations.compile options { failOnError false encoding &quot;UTF-8&quot; charSet &#39;UTF-8&#39; author true version true links &quot;http://docs.oracle.com/javase/7/docs/api&quot; } } task javadocJar(type: Jar, dependsOn: javadoc) { classifier = &#39;javadoc&#39; from javadoc.destinationDir } artifacts { archives javadocJar archives sourcesJar } uploadArchives { repositories { mavenDeployer { repository(url: &quot;$nexusRepositoryUrl&quot;) { authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) } pom.project { name LIB_ARTIFACT groupId LIB_GROUP artifactId LIB_ARTIFACT version version packaging &#39;aar&#39; description LIB_DES } } } } 然后在moudle中的gradle添加apply from: &#39;../nexus.gradle&#39;。 可以看到，在nexus.gradle这个脚本中有一些常量，这些常量需要写在gradle.properties中，相当于配置的参数。 NEXUS_SNAPSHOTS=http://yourhost:8081/repository/maven-snapshots/ NEXUS_RELEASES=http://yourhost:8081/repository/maven-releases/ NEXUS_USERNAME=admin NEXUS_PASSWORD=admin123 LIB_DES=hj web mch5web LIB_GROUP=com.xun.mch5web LIB_ARTIFACT=browser LIB_VERSION=1.0.5 LIB_IS_RELEASE=false //如果是true就是release版本，如果是false就是snapshot版本，release版本不可版本覆盖，需管理员手动删除 看变量名基本也能猜出每个变量的含义，这里也不在赘述了。 准备工作就绪，可以安心专注于Android SDK的开发了，开发完了就需要上传，直接在项目目录控制台运行./gradlew clean build upload（其实upload就行，编译后上传）。 还有种方法，Android Studio 中打开右侧的 Gradle 侧边栏，打开项目名,可以看到uploadArchives,这就是刚才创建的上传 Task,点击即可完成上传。 以上，成功之后可以在Nexus仓库中看到上传的相关文件。 5.Android工程依赖Nexus相关包上传已经OK，如果有一个Android工程（Application）想依赖刚刚上传的library，应该这么玩。 首先在rootProject的build.gradle中引用私库地址，我引用的是 maven-public聚合仓库的地址： maven { url &#39;http://yourhost:8081/repository/maven-public/&#39; } 引用该三方库的目标Module的build.gradle中添加此库的依赖： compile &#39;com.xun.mch5web:browser:1.0.5-SNAPSHOT&#39; snapshot版本是可以版本覆盖的，有时候依赖会有缓存，可以尝试使用以下命令清除缓存 ./gradlew build --refresh-dependencies 6.将nexus部署到远程服务器和迁移相关以上整个流程算是通了，不过在实际运用中，nexus肯定是需要部署在公司内网的物理或者虚拟机上的，下面用阿里云的云主机做一个模拟（系统是centos7.X）。 JDK环境确认没问题之后，使用wget 下载url命令把nexus的压缩包 上图下载了两个版本，使用的是3.15那个。 然后根据前文按部就班，运行起来之后就是远程主机ip+8081（默认）的方式被外网访问（nexus运行之后可以ps aux | grep &quot;nexus&quot;看看进程是否存在，阿里云的主机需要在阿里云后台去开启对应的端口，这个非常坑，千万不要忘了）。 至于用法也是一样的，就不多说了。 再来简单说一下迁移的事情，前面我们可以看到，在nexus解压包中会解压出一个名叫sonatype-work的文件夹，平时备份好这个文件夹的所有文件就OK了，还原的时候可以直接进行替换。nexus2.X的方式可能有些不一样，暂时还没研究过。 7.总结内容以上，公司如果又横向团队，这个也算是必备的技术了，高效率总是一点一滴累积出来的，技术没有高尚与低贱，能提高生产力的，就是好的。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"EOS爬行记（章一） --- EOS环境搭建与基本命令","date":"2018-07-07T16:00:00.000Z","path":"2018/07/08/EOS爬行记1/","text":"开篇：虽然币市低迷几近一年，不过并不影响EOS对于大众的关注程度，不管是暴涨还是暴跌，亦或是主网上线还是RAM的热度。作为一个IT从业人员来说，除了买买币之外还有另外的关注了解途径，也可谓是幸运的。笔者几个月下来，从以太坊玩到星云链，到现在也试图跨入EOS的大门，区块链的火爆表象下埋藏的是许许多多的计算机技术，数学知识，经济学原理，正如胡适说的那句话“怕什么真理无穷，进一寸有一寸的欢喜”。 本来也是想网上找找教程就随便玩玩的，没想到EOS的坑实在是太多，相对配套的东西也远远不及以太坊，在这里记录一则是为自己留个备案日后查阅，再则有他人有需要，可以按坑对号查询。 1.环境说明这个很重要，坑多的第一步就是因为不同的系统环境，系统版本，不同的EOS版本等等都会导致各种各样的坑，目前成功的相关参数如下： 系统版本：MAC 0S 10.13.4 此外网上有人建议至少20G硬盘与8G以上的内存。 2.下载源码git clone https://github.com/eosio/eos --recursive 最后一个参数需要带上，当然忘了了带上相关的submodule就不会clone下来，执行下一步的时候也会提醒你输入 git submodule update --init --recursive 来补救。当然，然并卵，不知道是VPN的问题还是其他，总之前几天不管这么clone都下不来，就算把zip下下来了手动考进项目编译也会出现各种各样奇葩的问题，山穷水复中发现了别人下好的全套源码放到百度云里的，抱着破罐子破摔的心理试一试然后就可以了，如果有类似问题的话使用下来链接 https://pan.baidu.com/s/1nXq32w2OBwI1GwUTslkBKg 3.代码编译与安装进入eos目录，使用 ./eosio_build.sh 然后就是各种下载或者编译进度条，只要不报错就没事，一直等着就行。报错就要搜搜对应的报错。 可以看看参考文档的第二篇，基本有个错误是绝逼会遇到的，不过只要有解决方案就是秒秒钟的事情。 看到以上这个就证明OK了，喜极而泣。 eos目录中build文件夹已经开放，进去看看里面有啥吧 eos/build/programs 大概解释如下： nodeos： 区块链服务器节点生成组建 cleos： 和区块链交互的接口命令 keosd： EOS 钱包 eosio-launcher：节点网络组成和部署的应用 在build目录下执行 sudo make install 可以把一些常用命令配置到系统中，然后可以use anywhere. 4.启动服务器两条命令 cd ~/eos/build/programs/nodeos ./nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::account_history_api_plugin 如果第二条觉得太麻烦可以做如下设置(基本上都会设置) /Users/用户名/Library/Application&#39; &#39;Support/eosio/nodeos/config 该目录下有一个config.ini文件，配置权限 修改 enable-stale-production = false 为 enable-stale-production = true，记得去掉前面的# 修改 producer-name = eosio ，记得去掉前面的# 添加 plugin = eosio::producer_plugin 添加 plugin = eosio::wallet_api_plugin 添加 plugin = eosio::chain_api_plugin 添加 plugin = eosio::http_plugin 修改完后，下次执行./nodeos即可 看到以上不断输出的数据证明启动成功，CTRL+C可以停止。 5.常用操作与基本命令单节点跑起来了，后面的操作都是基于这个本地节点的，故都需要重新起一个终端。 看看一些命令 5.1 查看区块信息➜ build git:(master) cleos -p 8888 get info { &quot;server_version&quot;: &quot;96ee0325&quot;, &quot;head_block_num&quot;: 16792, &quot;last_irreversible_block_num&quot;: 16791, &quot;head_block_id&quot;: &quot;00004198c3c0e383c1e0baf889a06c7c8171ab8d7ce7432ca2c36225e63508ed&quot;, &quot;head_block_time&quot;: &quot;2018-07-08T07:04:44&quot;, &quot;head_block_producer&quot;: &quot;eosio&quot; } 5.2 钱包设置cleos wallet create 会创建一个名为default的钱包 5.3 创建其他钱包与查看钱包➜ build git:(master) cleos wallet create --name test Creating wallet: test Save password to use in the future to unlock this wallet. Without password imported keys will not be retrievable. &quot;PW5JELVZv15CJ51XDTTFBy4ZsEKQ1S3u4XhsANs7huigF8pnwD2bK&quot; ➜ build git:(master) cleos wallet list Wallets: [ &quot;default *&quot;, &quot;test *&quot; ] 当然命令有错时会给上相应的帮助 ➜ build git:(master) cleos wallet ERROR: RequiredError: Subcommand required Interact with local wallet Usage: cleos wallet SUBCOMMAND Subcommands: create Create a new wallet locally open Open an existing wallet lock Lock wallet lock_all Lock all unlocked wallets unlock Unlock wallet import Import private key into wallet list List opened wallets, * = unlocked keys List of private keys from all unlocked wallets in wif format. 5.4 为账号部署合约cleos set contract eosio ../../contracts/eosio.bios -p eosio 5.5 创建2个key，导入key的私钥cleos create key Private key: 5Kg4i6WW6mfGXGjriU552KdAQ8tQyCU4mqtevVganWWbzQf1rD1 Public key: EOS5MSkE5DGgSurc7k3Sv9kWrev6E3GBBqasdiiC3yajPwrW7c4Uq cleos create key Private key: 5Kg2P7PRA7wWrW2s53JiaBur7PhDtDsCMZUwQ8Yvn8uAmu8xEMB Public key: EOS7wERhooVJwqYLuQn5v6UDZnL5KQpGJBDMQoktkxz4baNzicwLX cleos wallet import 5Kg4i6WW6mfGXGjriU552KdAQ8t QyCU4mqtevVganWWbzQf1rD1 imported private key for: EOS5MSkE5DGgSurc7k3Sv9kWrev6E3GBBqasdiiC3yajPwrW7c 4Uq cleos wallet import 5Kg2P7PRA7wWrW2s53JiaBur7Ph DtDsCMZUwQ8Yvn8uAmu8xEMB imported private key for: EOS7wERhooVJwqYLuQn5v6UDZnL5KQpGJBDMQoktkxz4baNzic wLX 创建两个账户是因为需要生成两个权限不一样的账户，一个是owner，一个是active。 5.6 􏳔􏲤􏲟􏱼􏰍􏳕􏳓􏰄􏱯􏰘􏳖􏳐根据生成的公钥创建账号cleos create account eosio eostoken EOS5MSkE5 DGgSurc7k3Sv9kWrev6E3GBBqasdiiC3yajPwrW7c4Uq EOS7wERhooVJwqYLuQn5v6UDZnL5KQp GJBDMQoktkxz4baNzicwLX 注意这个eostoken是账户名，是可以随便取的，不过一旦取了，后面就有很多地方要用，切记。 5.7 查看账户信息➜ build git:(master) cleos get account eostoken { &quot;account_name&quot;: &quot;eostoken&quot;, &quot;permissions&quot;: [{ &quot;perm_name&quot;: &quot;active&quot;, &quot;parent&quot;: &quot;owner&quot;, &quot;required_auth&quot;: { &quot;threshold&quot;: 1, &quot;keys&quot;: [{ &quot;key&quot;: &quot;EOS6YN37pfrCgUmw8SuWvXo4bCTaJPHm9GaCoKq9hZK7rD6z4uLcT&quot;, &quot;weight&quot;: 1 } ], &quot;accounts&quot;: [] } },{ &quot;perm_name&quot;: &quot;owner&quot;, &quot;parent&quot;: &quot;&quot;, &quot;required_auth&quot;: { &quot;threshold&quot;: 1, &quot;keys&quot;: [{ &quot;key&quot;: &quot;EOS7kkFv5AFj3r83fPmow5CC3bPqeDZXncabiN7at2Dxoz9v3bEvC&quot;, &quot;weight&quot;: 1 } ], &quot;accounts&quot;: [] } } ] } 5.8 检测部署合约cleos get code eostoken code hash: 0000000000000000000000000000000000000000000000000000000000000000 cleos set contract eostoken ../../contracts/currency cleos get code eostoken code hash: d6c891fbdfcff597d82e17c81354574399b01d533e53d412093f03e1950fb9d4 5.9 创建货币cleos push action eostoken create &#39;{&quot;issuer&quot;:&quot;eostoken&quot;,&quot;maximum_supply&quot; :&quot;1000000.0000 CUR&quot;,&quot;can_freeze&quot;:&quot;0&quot;,&quot;can_recall&quot;:&quot;0&quot;,&quot;can_whitelist&quot;:&quot;0&quot;}&#39; --permission eostoken@active 5.10 发行货币cleos push action eostoken issue &#39;{&quot;to&quot;:&quot;eostoken&quot;,&quot;quantity&quot;:&quot;1000.0000 CUR&quot;,&quot;memo&quot;:&quot;&quot;}&#39; --permission eostoken@active 5.11 查看账号信息cleos get table eostoken eostoken accounts 5.12 转账cleos push action eostoken transfer &#39;{&quot;from&quot;:&quot;eostoken&quot;,&quot;to&quot;:&quot;eosio&quot;,&quot;quantity&quot;:&quot;20.0000 CUR&quot;,&quot;memo&quot;:&quot;my first transfer&quot;}&#39; --permission eostoken@active 6.总结网上资料不多且鱼龙混杂，想要迈出第一步的确不容易，以上虽然是跑通了但是很多概念很原理都没有系统性的了解，后面的路还很长，后面有新的东西再来更新。 参考文档：1.https://blog.csdn.net/munianhua/article/details/797963442.http://blog.eosdata.io/index.php/tag/mac/3.http://www.8btc.com/eos-develop-environment","tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://same4869.github.io/tags/blockchain/"}]},{"title":"DAPP开发实战之投票系统","date":"2018-04-04T16:00:00.000Z","path":"2018/04/05/DAPP开发实战之投票系统/","text":"&emsp;&emsp;区块链技术其实大概已经出来很长一段时间了，只是在去年随着各种ico着实是火了一把。如同很多刚出现的技术与概念一样，信仰者奉之为神，觉得甚至是可以在短时间内颠覆支付宝的东西；而不信的人又是嗤之以鼻，认为不过都是些骗人的老套路套着新概念又重出江湖罢了。这是最好的时代，也是最坏的时代，人人都可能相比于几十年前不用那么勤奋努力很多很多年才能获得足够的财富，而就是因为人人都有机会，才让竞争也变得激烈异常。 &emsp;&emsp;作为技术研究者一般都信仰技术无罪，本文也无意谈太多技术之外的八卦，文章的技术核心内容基本都是来自于网上加以整理和实践，没有比模仿更适合了解和掌握一门新技术了。 一.项目框架概述 &emsp;&emsp;开门见山地，上图反应出一种互不信任的，去中心化的投票系统架构，和其他去中心化系统一样，它并没有一个中央服务器来保存数据，每个运行的节点（用户运行的客户端）都保留一份完整的全链路数据，区块链不断增长且不可篡改，每个节点都完全平等。每次数据的变动都是客户端与各自节点实例的交互，然后广播全网络同步的过程，如下图 &emsp;&emsp;当然，这是一种比较理想的情况，在移动互联网时代这可能是最急迫需要解决的问题，相信也很少有人能够忍受在手机上运行DAPP像在PC上打开以太坊全量钱包那样可能等上个一整天去同步所有区块数据。区块链社区也已经出现了一些解决方案，例如提供公共区块链节点的Infura, 以及浏览器插件Metamask等。通过这些方案，就不需要花费大量的硬盘、内存和时间去下载并运行完整的区块链节点，同时也可以利用去中心化的优点。当然这并不是本文所要讨论的重点。 &emsp;&emsp;以下是本次应用的架构图 &emsp;&emsp;从图中可以看到，网页通过（HTTP上的）远程过程调用（RPC：Remote Procedure Call）与区块链节点进行通信。web3.js已经封装了以太坊规定的全部RPC调用，因此利用它就可以与区块链进行交互，而不必手写那些RPC请求包。使用web3.js的另一个好处是，我们可以使用自己喜欢或擅长的前端框架来构建出色的web应用。 &emsp;&emsp;由于获得一个同步的全节点相当耗时，并占用大量磁盘空间。为了能快速地掌握如何开发一个去中心化应用，本文将使用ganache软件来模拟区块链节点，以便快速开发并测试应用，从而可以将注意力集中在去中心化的思想理解与DApp应用逻辑开发方面。 &emsp;&emsp;接下来，我们先将编写一个投票合约，然后编译合约并将其部署到区块链节点 —— ganache上。 &emsp;&emsp;最后，我们将分别通过命令行和网页这两种方式，与区块链进行交互。 二.使用Node.js进行第一次迭代2.1 &emsp;&emsp;由于各自环境的不同，这里以MAC为准，其他平台可以自行用谷歌百度一下。 由上文可知，首先是安装gannache使用命令sudo npm install -g ganache-cli关于Ganache可以百度先了解一下 Ganache：以前叫作 TestRPC，它在 TestRPC 和 Truffle 的集成后被重新命名为 Ganache。Ganache 的工作很简单：创建一个虚拟的以太坊区块链，并生成一些我们将在开发过程中用到的虚拟账号。 安装完毕后在控制台输入ganache-cli命令，可以看到以下结果这样就相当于一个私链已经存在了，并且ganache默认创建了10个测试账号，每个账号里面也会有一些余额。 当然还有一个GUI版本的，有兴趣也可以用这个http://truffleframework.com/ganache/#2/_blank &emsp;&emsp;以太坊开发目前都是使用Solidity语言进行开发，个人感觉如果有面向对象基础的话就不要从最最基本的语法看起，可能还没入门就直接想放弃了，这也是为什么要鼓励直接实战的原因。下图是投票合约的主要接口基本上，投票合约Voting包含以下内容： 构造函数，用来初始化候选人名单。 投票方法Vote()，每次执行就将指定的候选人得票数加 1 获得票数查询方法totalVotesFor()，执行后将返回指定候选人的得票数 有几点需要注意一下： 合约状态是持久化到区块链上的，因此对合约状态的修改需要消耗以太币。 只有在合约部署到区块链的时候，才会调用构造函数，并且只调用一次。 与 web 世界里每次部署代码都会覆盖旧代码不同，在区块链上部署的合约是不可改变的，也就是说，如果你更新合约并再次部署，旧的合约仍然会在区块链上存在，并且合约的状态数据也依然存在。新的部署将会创建合约的一个新的实例。 2.2下面直接看看投票合约代码 pragma solidity ^0.4.18; contract Voting { mapping (bytes32 =&gt; uint8) public votesReceived; bytes32[] public candidateList; function Voting(bytes32[] candidateNames) public { candidateList = candidateNames; } function totalVotesFor(bytes32 candidate) view public returns (uint8) { require(validCandidate(candidate)); return votesReceived[candidate]; } function voteForCandidate(bytes32 candidate) public { require(validCandidate(candidate)); votesReceived[candidate] += 1; } function validCandidate(bytes32 candidate) view public returns (bool) { for(uint i = 0; i &lt; candidateList.length; i++) { if (candidateList[i] == candidate) { return true; } } return false; } } 代码不长，大概有下面几个点 编译器版本声明 合约类声明，构造函数 字典，数组 函数，断言 稍微看看应该就基本都能看懂。 我们使用solc库来编译合约代码。然后使用web3js库，它能够让你通过RPC与区块链进行交互。我们将在node控制台里用这个库编译和部署合约，并与区块链进行交互。首先，请确保ganache已经在第一个终端窗口中运行：~$ ganache-cli。 $ node &gt; Web3 = require(&#39;web3&#39;) &gt; web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://localhost:8545&quot;)); &gt; web3.eth.accounts 要编译合约，首先需要载入Voting.sol文件的内容，然后使用编译器（solc）的compile()方法对合约代码进行编译： &gt; code = fs.readFileSync(&#39;Voting.sol&#39;).toString() &gt; solc = require(&#39;solc&#39;) &gt; compiledCode = solc.compile(code) 以上只要没报错就OK，尤其是compiledCode,会出现特别多的输出信息。其中包含两个重要的字段： compiledCode.contracts[&#39;:Voting&#39;].bytecode: 投票合约编译后的字节码，也是要部署到区块链上的代码。 compiledCode.contracts[&#39;:Voting&#39;].interface: 投票合约的接口，被称为应用二进制接口（ABI：Application Binary Interface），它声明了合约中包含的接口方法。无论何时需要跟一个合约进行交互，都需要该合约的abi定义。 2.3合约编译基本已完成，接下来看看怎么部署到区块链上去。为此，需要先传入合约的abi定义来创建合约对象VotingContract，然后利用该对象完成合约在链上的部署和初始化。命令如下 &gt; abiDefinition = JSON.parse(compiledCode.contracts[&#39;:Voting&#39;].interface) &gt; VotingContract = web3.eth.contract(abiDefinition) &gt; byteCode = compiledCode.contracts[&#39;:Voting&#39;].bytecode &gt; deployedContract = VotingContract.new([&#39;Rama&#39;,&#39;Nick&#39;,&#39;Jose&#39;],{data: byteCode, from: web3.eth.accounts[0], gas: 4700000}) &gt; deployedContract.address &gt; contractInstance = VotingContract.at(deployedContract.address) 调用VotingContract对象的new()方法来将投票合约部署到区块链。new()方法参数列表应当与合约的构造函数要求相一致。对于投票合约而言，new()方法的第一个参数是候选人名单。 new()方法的最后一个参数用来声明部署选项。先来看一下这个参数的内容： { data: byteCode, //合约字节码 from: web3.eth.accounts[0], //部署者账户，将从这个账户扣除执行部署交易的开销 gas: 4700000 //愿意为本次部署最多支付多少油费，单位：Wei } data: 这是合约编译后，需要部署到区块链上的合约字节码。 from: 区块链必须跟踪是谁部署了一个合约。在本例中，我们简单地利用web3.eth.accounts返回的第一个账户，作为部署这个合约的账户。在提交交易之前，你必须拥有并解锁这个账户。不过为了方便起见，ganache默认会自动解锁这10个账户。 gas: 与区块链进行交互需要消耗资金。这笔钱用来付给矿工，因为他们帮你把代码部署到在区块链里。你必须声明愿意花费多少资金让你的代码包含在区块链中，也就是设定gas的值。from字段声明的账户的余额将会被用来购买 gas。gas的价格则由区块链网络设定。 2.4拿到contractInstance实例之后可以根据合约定义的接口进行一系列的操作了。 调用合约的totalVotesFor()方法来查看某个候选人的得票数。例如，下面的代码查看候选人Rama的得票数：contractInstance.totalVotesFor.call(&#39;Rama&#39;) { [String: &#39;0&#39;] s: 1, e: 0, c: [ 0 ] } 是数字 0 的科学计数法表示. 调用合约的voteForCandidate()方法投票给某个候选人。下面的代码就是给Rama投了三次票： &gt; contractInstance.voteForCandidate(&#39;Rama&#39;, {from: web3.eth.accounts[0]})&gt; contractInstance.voteForCandidate(&#39;Rama&#39;, {from: web3.eth.accounts[0]})&gt; contractInstance.voteForCandidate(&#39;Rama&#39;, {from: web3.eth.accounts[0]}) 现在我们再次查看Rama的得票数：&gt;contractInstance.totalVotesFor.call(&#39;Rama&#39;).toLocaleString() &#39;3&#39; 每执行一次投票，就会产生一次交易，因此voteForCandidate()方法将返回一个交易id，作为交易的凭据。比如：0xdedc7ae544c3dde74ab5a0b07422c5a51b5240603d31074f5b75c0ebc786bf53。交易id是交易发生的凭据，交易是不可篡改的，因此任何时候可以使用交易id引用或查看交易内容都会得到同样的结果。对于区块链而言，交易不可篡改是其核心特性。 2.5让用户使用命令行显然是非常不友好的，所以接下来尝试使用网页来作为前端交互页面。页面的主要功能如下： 列出所有的候选人及其得票数 用户在页面中可以输入候选人的名称，然后点击投票按钮，网页中的JS代码将调用投票合约的voteForCandidate()方法 —— 和我们nodejs控制台里的流程一样。 先来看看html代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href=&#39;/lib/gfonts.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;link href=&#39;/lib/bootstrap.min.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;/head&gt; &lt;body class=&quot;container&quot;&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id=&quot;candidate-1&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id=&quot;candidate-2&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id=&quot;candidate-3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;candidate&quot; /&gt; &lt;a href=&quot;#&quot; onclick=&quot;voteForCandidate()&quot; class=&quot;btn btn-primary&quot;&gt;Vote&lt;/a&gt; &lt;/body&gt; &lt;script src=&quot;/lib/web3.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/lib/jquery-3.1.1.slim.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; 里面引用了一些基本的JS库，此外还有web3.js和index.js，为了方便跑代码把这文章的相关代码都传上了git,需者自取。 https://github.com/same4869/dappDemo 其他的js文件包括web3.js都是库文件，没有业务逻辑，而需要我们关注的是index.js这个文件，也是我们自己写的js文件。 web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://192.168.0.6:8545&quot;)); abi = JSON.parse(&#39;[{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;candidate&quot;,&quot;type&quot;:&quot;bytes32&quot;}],&quot;name&quot;:&quot;totalVotesFor&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint8&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;candidate&quot;,&quot;type&quot;:&quot;bytes32&quot;}],&quot;name&quot;:&quot;validCandidate&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bytes32&quot;}],&quot;name&quot;:&quot;votesReceived&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint8&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[{&quot;name&quot;:&quot;x&quot;,&quot;type&quot;:&quot;bytes32&quot;}],&quot;name&quot;:&quot;bytes32ToString&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;candidateList&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bytes32&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;candidate&quot;,&quot;type&quot;:&quot;bytes32&quot;}],&quot;name&quot;:&quot;voteForCandidate&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;contractOwner&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[{&quot;name&quot;:&quot;candidateNames&quot;,&quot;type&quot;:&quot;bytes32[]&quot;}],&quot;payable&quot;:false,&quot;type&quot;:&quot;constructor&quot;}]&#39;) VotingContract = web3.eth.contract(abi); contractInstance = VotingContract.at(&#39;0x1eb79b83e6e8c9ca16355c5a817ad9fa456e1e03&#39;); candidates = {&quot;Rama&quot;: &quot;candidate-1&quot;, &quot;Nick&quot;: &quot;candidate-2&quot;, &quot;Jose&quot;: &quot;candidate-3&quot;} function voteForCandidate(candidate) { candidateName = $(&quot;#candidate&quot;).val(); try { contractInstance.voteForCandidate(candidateName, {from: web3.eth.accounts[0]}, function() { let div_id = candidates[candidateName]; $(&quot;#&quot;+div_id).html(contractInstance.totalVotesFor.call(candidateName).toString()); }); } catch (err) { } } $(document).ready(function() { candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) { let name = candidateNames[i]; let val = contractInstance.totalVotesFor.call(name).toString() $(&quot;#&quot;+candidates[name]).html(val); } }); 为了将页面运行起来，需要对JS代码进行一下调整：节点的RPC API地址web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://localhost:8545&quot;));HttpProvier()对象的构造函数参数是web3js库需要链接的以太坊节点RPC API的URL。 当一个合约部署到区块链上时，将获得一个地址，例如0x329f5c190380ebcf640a90d06eb1db2d68503a53。 由于每次部署都会获得一个不同的地址，因此你需要指定它：contractInstance = VotingContract.at(&#39;0x329f5c190380ebcf640a90d06eb1db2d68503a53&#39;) 在第二个终端中输入以下命令来启动一个简单的Web服务器，以便我们可以在试验环境中的嵌入浏览器中访问页面： ~$ cd ~/repo/chapter1 ~/repo/chapter1$ python -m SimpleHTTPServer (python3使用这个，下同) python -m http.server 80 Python的SimpleHTTPServer模块将启动在8000端口的监听。现在，在试验环境的嵌入浏览器中点击刷新按钮。如果一切顺利的话，你应该可以看到投票应用的页面了。 当你在文本框中输入候选人姓名，例如Rama，然后点击按钮后，应该会看到候选人Rama的得票数加 1 。 2.6如果能看到页面，并能够正常投票，第一个基本demo已经能跑起来了。 总结一下，下面是我们到目前为止已经完成的事情： 使用nodejs,npm和ganache作为开发环境。 开发简单的投票合约，编译并部署到区块链节点上。 使用nodejs控制台与合约交互。 编写网页与合约交互。 所有的投票都保存到区块链上，并且不可修改。 任何人都可以独立验证每个候选人获得了多少投票。 三.使用Truffle进行第二次迭代3.1上一章我们已经基于区块链（ganache仿真器）实现了一个投票合约，并且成功通过nodejs控制台和网页实现了与合约的交互。 而接下来我们试着做以下这些事 使用Truffle框架开发投票应用，它可以方便地编译、部署合约。 修改已有的投票应用代码，以便适配开发框架。 利用Truffle控制台、网页与投票合约进行交互。 对投票合约进行扩展，加入通证（token）及购买功能。 对前端代码进行扩展，通过网页前端购买股票通证，并利用股票通证为候选人投票。 Truffle可以先了解下，和各种PHP,Python,JS框架异曲同工，能帮助开发者开发DAPP事半功倍,省去很多手工操作。 首先还是安装~$ npm install -g truffle Truffle提供了众多的项目模版，可以快速搭建一个去中心化应用的骨架代码。下面的代码使用webpack项目模版来创建应用tfapp: ~$ mkdir -p ~/repo/tfapp ~$ cd ~/repo/tfapp ~/repo/tfapp$ truffle unbox webpack 初始化一个Truffle项目时，它会创建运行一个完整的DApp所需的文件和目录。 可以使用ls命令来查看生成的项目结构： ~/repo/tfapp$ ls README.md contracts node_modules test webpack.config.js truffle.js app migrations package.json ~/repo/tfapp$ ls app/ index.html javascripts stylesheets ~/repo/tfapp$ ls contracts/ ConvertLib.sol MetaCoin.sol Migrations.sol ~/repo/tfapp$ ls migrations/ 1_initial_migration.js 2_deploy_contracts.js 前面的章节中主要自己编写了3个文件，分别是Voting.sol,index.html与index.js，现在对这几个文件分别进行处理，以便应用到Truffle生成的应用中。 Voting.sol 合约文件不需要修改，直接拷贝到 contracts目录即可： ~/repo/tfapp$ cp ../chapter1/Voting.sol contracts/ ~/repo/tfapp$ ls contracts/ Migrations.sol Voting.sol index.html 先将页面文件拷贝到app目录，覆盖Truffle生成的index.html： ~/repo/tfapp$ cp ../chapter1/index.html app/ 由于Truffle的webpack模版在打包JS脚本时，默认使用app.js作为打包入口， 因此，我们将页面文件中对index.js的引用改为对app.js的引用：&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; app.js 在Truffle下，我们需要重写与区块链交互的JS脚本。由于使用webpack打包，因此可以使用ES2015语法。 当使用Truffle来编译和部署合约时，框架会将合约的应用接口定义（abi：Application Binary interface）以及部署地址保存到build/contracts目录中同名的json文件中 —— 我们不需要自己记部署地址了！ 例如，Voting.sol的部署信息对应与build/contracts/Voting.json文件。利用这个文件就可以创建投票合约对象： import voting_artifacts from &#39;../../build/contracts/Voting.json&#39; var Voting = contract(voting_artifacts) 合约对象的deployed()方法返回一个Promise，其解析值为该合约对象的部署实例代理（真正的实例在链上），利用这个代理可以执行合约的方法： Voting.deployed() .then(instance =&gt; instance.voteForCandidate(&#39;Rama&#39;)) .then(() =&gt; instance.totalVotesFor.call(&#39;Rama&#39;)) .then(votes =&gt; console.log(&#39;Rama got votes: &#39;, votes)) 可以根据git下来的结构目标查看对应的文件自行参考与替换。 3.2迁移（migration）目录的内容非常重要。Truffle使用该目录下的迁移脚本来管理应用合约的部署。 我们在之前的操作中，是通过在 node 控制台中调用合约对象的new()方法来将投票合约部署到区块链上。有了Truffle，就再也不需要这么做了。 第一个迁移脚本1_initial_migration.js的作用是向区块链部署Migrations合约， 这个合约的作用是存储并跟踪已经部署的最新合约。每次运行迁移任务时，Truffle就会向区块链查询获取 已部署好的合约，然后部署新的合约。在部署完成后，这个脚本会更新Migrations合约中的last_completed_migration字段指向最新部署的合约。可以简单地把Migrations合约当成是一个数据库表，字段last_completed_migration总是保持最新状态。 将迁移脚本2_deploy_contracts.js的内容修改为以下内容，以便部署我们的投票合约Voting： var Voting = artifacts.require(&quot;./Voting.sol&quot;); module.exports = function(deployer) { deployer.deploy(Voting, [&#39;Rama&#39;, &#39;Nick&#39;, &#39;Jose&#39;], {gas: 290000}); }; 从上面的代码可以看出，Truffle框架将向迁移脚本传入一个部署器对象（deployer），调用其deploy()方法即可实现指定合约的部署。 deploy()方法的第一个参数为要部署合约的编译对象，调用artifacts.require()即可直接将合约代码转换为合约编译对象，例如：artifacts.require(&#39;./Voting.sol&#39;) 。 容易理解，Truffle的artifacts对象自动调用solidity编译器来编译合约代码文件并返回编译结果对象。 deploy()方法的最后一个参数是合约实例化选项对象，可以用来指定部署代码所需的油费 —— 别忘了部署合约也是交易，因此需要烧点油（gas）。gas 数量会随着你的合约大小而变化 —— 确切的说，部署一个合约所需的油费取决于编译生成的合约字节码，不同的字节码指令对应不同的开销，累加起来就可以估算出部署费用。 对于投票合约而言，290000个油就足够了 —— 这个价格是我们为部署这个合约愿意承担的最大费用（gasLimit），最终的开支可能用不了这么多。当然，如果你的合约很复杂，有可能你愿意买单的这个上限还不够，那么 节点就会返回一个提示，告诉你部署失败，油资不足 —— Out of gas deploy()方法的第一个参数和最后一个参数之间，需要按合约构造函数的参数要求依次传入。例如，对于投票合约，我们只需传入一个候选人名单（数组）。 Truffle在执行任务时，将读取当前目录下的配置文件truffle.js。通常我们在该配置文件中声明要连接的以太坊节点地址，例如localhost:8545： require(&#39;babel-register&#39;)module.exports = { networks: { dev: { host: &#39;localhost&#39;, port: 8545, network_id: &#39;*&#39;, gas: 470000 } } } 你应该会注意到gas选项。这是一个会应用到所有迁移任务的全局变量。当我们调用deploy()方法部署一个合约时，如果没有声明愿意承担的油费，那么Truffle就会采用这个值作为该合约的部署油资。 另一个值得指出的是，Truffle支持将合约部署到多个区块链网络，例如开发网络、私有网络、测试网或公网。 在上面的配置文件中，我们仅定义了一个用于开发的网络dev —— 你知道它指向的是ganache模拟器，Truffle 在执行命令时将自动连接到这个网络。 3.3在Truffle中执行compile命令来编译contracts下的所有合约： ~/repo/tfapp$ truffle compile Compiling Migrations.sol... Compiling Voting.sol... Writing artifacts to ./build/contracts 在Truffle中执行migrate命令将编译后的合约部署到链上： ~/repo/tfapp$ truffle migrate Running migration: 1_initial_migration.js Deploying Migrations...Migrations: 0x3cee101c94f8a06d549334372181bc5a7b3a8bee Saving successful migration to network... Saving artifacts... Running migration: 2_deploy_contracts.js Deploying Voting...Voting: 0xd24a32f0ee12f5e9d233a2ebab5a53d4d4986203 Saving successful migration to network... Saving artifacts... 以上如果有编译错误可以根据提示解决。 如果由于油费不足而导致部署失败，可以尝试增加migrations/2_deploy_contracts.js 里面的 gas 值。比如： deployer.deploy(Voting, [&#39;Rama&#39;, &#39;Nick&#39;, &#39;Jose&#39;], {gas: 500000}) 如果希望自选一个账户来部署合约，而不是使用默认的accounts[0]，可以在迁移脚本中使用from 选项指定，例如： deployer.deploy(Voting, [&#39;Rama&#39;, &#39;Nick&#39;, &#39;Jose&#39;], {gas: 500000,from:&#39;0x8cff691c888afe73ffa3965db39be96ba3b34e49&#39;}) 也可以在 truffle.js 中指定默认的用来与区块链交互的账户地址： module.exports = { networks: { dev: { host: &#39;localhost&#39;, port: 8545, network_id: &#39;*&#39;, gas: 470000, from: &#39;0x8cff691c888afe73ffa3965db39be96ba3b34e49&#39; } } } 3.4部署顺利的话，现在就可以通过控制台和网页与合约进行交互了。使用Truffle控制台在第二个终端中输入truffle console命令进入控制台： ~/repo/tfapp$ truffle console truffle(development)&gt; Voting.deployed().then(function(contractInstance) {contractInstance.voteForCandidate(&#39;Rama&#39;).then(function(v) {console.log(v)})}) { blockHash: &#39;0x7229f668db0ac335cdd0c4c86e0394a35dd471a1095b8fafb52ebd7671433156&#39;,blockNumber: 469628,contractAddress: null, .... .... truffle(default)&gt; Voting.deployed().then(function(contractInstance) {contractInstance.totalVotesFor.call(&#39;Rama&#39;).then(function(v) {console.log(v)})}) { [String: &#39;1&#39;] s: 1, e: 0, c: [ 1] } 注意，truffle 的所有调用都会返回promise，这就是为什么每个响应都被包裹在 then()函数里的原因。 通过网页交互，首先使用 ~/repo/tfapp$ webpack 在build目录下生成相应的文件，注意webpack的版本（这里推荐2.X），可以用npm进行调整，被这个坑坑了半天时间。 然后进入build目录，先建立网页资源文件的符号连接，然后启动web服务器： ~/repo/tfapp/build$ ln -s ~/repo/common/lib lib ~/repo/tfapp/build$ ln -s ~/repo/common/fonts fonts ~/repo/tfapp/build$ python -m SimpleHTTPServer （python3）python -m http.server 8000 现在，在浏览器中点击刷新按钮，没问题的话就能看到效果了。 四.引入数字代币进行第三次迭代4.1接下来就是比较有意思又比较熟悉的Token了，在以太坊中，一个重要概念就是通证（token），也就是常说的加密数字币，或者代币。通证就是在以太坊上构建的数字资产，可以用它来表示现实世界里的东西，比如黄金，或者是自己的数字资产（就像货币一样）。通证实际上就是智能合约，并没有什么太多的神奇之处。 黄金通证：银行可以有1千克的黄金储备，然后发行1千个通证。买100个黄金通证就等于买100克的黄金。 公司股票：公司股票可以用以太坊上的代币来表示。通过支付以太，人们可以购买公司股票。 游戏币：在一个多玩家游戏中，游戏者可以用以太购买游戏币，并在游戏中进行消费。 Golem通证：这是一个基于以太坊的真实项目，个人可以通过租售空闲的 CPU来赚取通证。 忠诚度积分：商店可以给购物者发行通证作为忠诚度积分，它可以在将来作为现金回收，或是在第三方市场售卖。 在合约中如何实现通证，实际上并没有限制。但是，以太坊有一个叫做ERC20的通证标准，该标准还在不断进化中。ERC20通证的优点是很容易与其他的符合ERC20标准的通证进行交换，同时，也更容易将你的通证集成到其他DApp中。总的来说，后续将讨论以下内容： 学习并掌握新的数据类型，比如结构体（struct），以便在区块链上组织和存储数据 理解通证概念并实现投票应用的通证 学习使用以太币进行支付，以太币是以太坊区块链平台的数字加密货币。 一提到投票，通常会想起普通的选举，例如，通过投票来选出一个国家的首相或总统。在这种情况下，每个公民都会有一票，可以投给他们支持的候选人。 还有另外一种加权投票（weighted voting），它常常用于公开上市交易的公司。 在这些公司，股东的投票权取决于其持有的股票数量。比如，如果你拥有 10,000 股公司股票，你就有 10,000 个投票权（而不是普通选举中的一票）。 例如，假设有一个叫做Block的上市公司。公司有 3 个空闲职位，分别是总裁、副总裁和部长，以及一组候选人。该公司希望通过股东投票的方式来决定哪个候选人得到哪个职位。获得最高票数的候选人将会成为总裁，然后是副总裁，最后是部长。 针对这个应用场景，我们可以构建一个DApp来发行公司股票，该应用允许任何人购买股票从而成为股东。 股东基于其拥有的股票数为候选人投票。例如，如果你持有10,000 股，你可以一个候选人投 5,000 股， 另一个候选人 3,000 股，第三个候选人 2,000 股。 以下是我们将要在本章实现应用的图示，任何人都可以调用合约的buy()方法来购买公司发行的股票通证，然后就可以调用合约的voteForCandidate()方法为特定的候选人投票： 4.2我们可以按以下思路来实现加权投票应用： 首先初始化一个新的truffle项目，然后修改关键代码文件： 投票合约：Voting.sol 合约迁移脚本：2_deploy_contracts.js 前端代码：index.html、app.js和app.css 在部署合约时初始化参与竞争的候选人名单。我们前面已经知道了如何实现这一点，在迁移脚本2_deploy_contracs.js中完成这个任务。 由于投票人需要先持有公司股票。所以，我们还需要在部署合约时初始化公司发行的股票总量。 这些股票就是构成公司的数字资产。在以太坊的世界中，这些数字资产被称为通证（Token）。 因此，从现在开始，我们将会把这些股票称为股票通证。 需要指出的是，股票可以看做是一种通证，但是并非所有的以太坊通证都是股票。股票仅仅是我们前一节中提到的通证使用场景的一种。 我们还需要向投票合约中增加一个新的方法，以便任何人都可以购买这些通证。容易理解，投票人给候选人投票时将使用（消耗）这些股票通证。 接下来还需要添加一个方法来查询投票人的信息，以及他们分别给谁投了票、总共持有多少股票通证、 还有多少可用的通证余额等等。 为了跟踪所有这些数据，我们需要使用几个mapping类型的字段，同时还需要引入新的数据类型 struct（结构体）来组织投票人信息。 和原来一样，我们使用truffle的webpack项目模版来初始化一个新项目， 并从contracts目录下移除无用的合约文件： ~$ mkdir -p ~/repo/tkapp ~$ cd ~/repo/tkapp ~/repo/tkapp$ truffle unbox webpack ~/repo/tkapp$ rm contracts/ConvertLib.sol contracts/MetaCoin.sol 4.3新的合约设计如下 之前的投票合约仅仅包含两个状态：数组candidateList保存候选人名单，字典votesReceived跟踪每个候选人获得的投票。 在加权投票合约中，我们需要额外跟踪一些数据： 投票人信息：solidity的结构体（struct）类型可以将相关数据组织在一起(类似于JAVA BEAN)。用结构体来存储投票人信息非常好。我们将使用一个struct来存储投票人的账户、已经购买的股票通证数量以及给每个候选人投票时所用的股票数量。例如： struct voter { address voterAddress; //投票人账户地址 uint tokensBought; //投票人持有的股票通证总量 uint[] tokensUsedPerCandidate; //为每个候选人消耗的股票通证数量 } 投票人信息字典：使用一个mapping字典来保存所有的投票人信息，键为投票人账户地址，值为投票人信息。 这样给定一个投票人的账户地址，就可以很方面地提取他的相关信息。我们使用voterInfo来表示该字典。 例如： mapping (address =&gt; voter) public voterInfo。 股票通证的相关信息：使用totalTokens来保存通证发行总量，balanceTokens保存通证余额，tokenPrice保存通证的价格。 在部署合约时，除了指定候选人名单，我们还需要声明股票通证发行总量和股票单价。 因此在合约的构造函数中，需要补充声明这些参数。例如： contract Voting{ function Voting(uint tokens, uint pricePerToken, bytes32[] candidateNames) public {} } 当股东调用voteForCandidate()方法投票给特定候选人时，还需要声明其支持力度 —— 用多少股票来支持 这个候选人。因此，我们需要为该方法添加额外的参数以便传入股票通证数量。例如： contract Voting{ function voteForCandidate(bytes32 candidate, uint votesInTokens) public {} } 任何人都可以调用buy()方法来购买公司发行的股票通证，从而成为公司的股东并获得投票权。 你应该已经注意到了该方法的payable修饰符。在Sodility合约中，只有声明为payable的方法， 才可以接收支付的货币（msg.value值）。 contract Voting{ function buy() payable public returns (uint) { //使用msg.value来读取用户的支付金额，这要求方法必须具有payable声明 } } 下面放出所有合约代码，也可以在git目录中查看 pragma solidity ^0.4.18; contract Voting { struct voter { address voterAddress; uint tokensBought; uint[] tokensUsedPerCandidate; } mapping (address =&gt; voter) public voterInfo; mapping (bytes32 =&gt; uint) public votesReceived; bytes32[] public candidateList; uint public totalTokens; uint public balanceTokens; uint public tokenPrice; function Voting(uint tokens, uint pricePerToken, bytes32[] candidateNames) public { candidateList = candidateNames; totalTokens = tokens; balanceTokens = tokens; tokenPrice = pricePerToken; } function buy() payable public returns (uint) { uint tokensToBuy = msg.value / tokenPrice; require(tokensToBuy &lt;= balanceTokens); voterInfo[msg.sender].voterAddress = msg.sender; voterInfo[msg.sender].tokensBought += tokensToBuy; balanceTokens -= tokensToBuy; return tokensToBuy; } function totalVotesFor(bytes32 candidate) view public returns (uint) { return votesReceived[candidate]; } function voteForCandidate(bytes32 candidate, uint votesInTokens) public { uint index = indexOfCandidate(candidate); require(index != uint(-1)); if (voterInfo[msg.sender].tokensUsedPerCandidate.length == 0) { for(uint i = 0; i &lt; candidateList.length; i++) { voterInfo[msg.sender].tokensUsedPerCandidate.push(0); } } uint availableTokens = voterInfo[msg.sender].tokensBought - totalTokensUsed(voterInfo[msg.sender].tokensUsedPerCandidate); require (availableTokens &gt;= votesInTokens); votesReceived[candidate] += votesInTokens; voterInfo[msg.sender].tokensUsedPerCandidate[index] += votesInTokens; } function totalTokensUsed(uint[] _tokensUsedPerCandidate) private pure returns (uint) { uint totalUsedTokens = 0; for(uint i = 0; i &lt; _tokensUsedPerCandidate.length; i++) { totalUsedTokens += _tokensUsedPerCandidate[i]; } return totalUsedTokens; } function indexOfCandidate(bytes32 candidate) view public returns (uint) { for(uint i = 0; i &lt; candidateList.length; i++) { if (candidateList[i] == candidate) { return i; } } return uint(-1); } function tokensSold() view public returns (uint) { return totalTokens - balanceTokens; } function voterDetails(address user) view public returns (uint, uint[]) { return (voterInfo[user].tokensBought, voterInfo[user].tokensUsedPerCandidate); } function transferTo(address account) public { account.transfer(this.balance); } function allCandidates() view public returns (bytes32[]) { return candidateList; } } 4.4合约的buy()方法用于提供购买股票的接口。注意关键字payable，有了它买股票的人才可以付钱给你。 接收钱没有比这个再简单的了！ function buy() payable public returns (uint) { uint tokensToBuy = msg.value / tokenPrice; //根据购买金额和通证单价，计算出购买量 require(tokensToBuy &lt;= balanceTokens); //继续执行合约需要确认合约的通证余额不小于购买量 voterInfo[msg.sender].voterAddress = msg.sender; //保存购买人地址 voterInfo[msg.sender].tokensBought += tokensToBuy; //更新购买人持股数量 balanceTokens -= tokensToBuy; //将售出的通证数量从合约的余额中剔除 return tokensToBuy; //返回本次购买的通证数量 } 当用户（或程序）调用合约的buy()方法时，需要在请求消息里利用value属性设置用于购买股票通证的以太币金额。例如： contract.buy({ value:web3.toWei(&#39;1&#39;,&#39;ether&#39;), //购买者支付的以太币金额 from:web3.eth.accounts[1] //购买者账户地址 }) 在合约的payable方法实现代码中使用msg.value来读取用户支付的以太币数额。 基于用户支付额和股票通证单价，就可以计算出购买数量，并将这些通证赋予购买人， 购买人的账户地址可以通过msg.sender获取。 当然，也可以从truffle控制台调用buy()方法来购买股票通证： truffle(development)&gt; Voting.deployed().then(function(contract) {contract.buy({value: web3.toWei(&#39;1&#39;, &#39;ether&#39;), from: web3.eth.accounts[1]})}) 如前所述，加权投票方法不仅要指定候选人名称，还要指定使用多少股票通证来支持该候选人。 我们分别用candidate和votesInTokens来表示这两个参数： function voteForCandidate(bytes32 candidate, uint votesInTokens) public {} 在投票人调用voteForCandidate()方法投票时，我们不仅需要为指定的候选人增加其投票数，还需要跟踪投票人的相关信息，比如投票人是谁（即其账户地址），以及给每个候选人投了多少票。因此在该方法的开始部分，检查如果是该投票人第一次参与投票的话，首先初始化该投票人的voterInfo结构： if (voterInfo[msg.sender].tokensUsedPerCandidate.length == 0) { for(uint i = 0; i &lt; candidateList.length; i++) { voterInfo[msg.sender].tokensUsedPerCandidate.push(0); //该投票人为每个候选人投入的通证数量初始化为0 } } 接下来我们计算该投票人当前的有效持股数量 —— 从该投票人的持股数量中扣除其为所有投票人已经消耗的股票通证数量： uint availableTokens = voterInfo[msg.sender].tokensBought - totalTokensUsed(voterInfo[msg.sender].tokensUsedPerCandidate) 显然，在合约继续执行之前，需要满足条件 —— 投票人的有效持股数量不小于本次投票使用的股票通证数量： require (availableTokens &gt;= votesInTokens) 如果投票人依然持有足够数量的股票通证，我们就更新候选人获得的票数，同时更新投票人的通证使用记录： votesReceived[candidate] += votesInTokens; voterInfo[msg.sender].tokensUsedPerCandidate[index] += votesInTokens; 当一个用户调用buy()方法发送以太来购买了合约发行的股票通证后，合约收到的资金去了哪里？ 所有收到的资金（以太）都在这个投票合约里。每个合约都有它自己的地址，因此也是一个账户。 在以太坊里，这种账户被称为合约账户（Contract Account），而之前的人员账户，则被称为外控账户 (External Controlled Account)。因此，合约的地址里存着这些销售收益。 我们新增加的transferTo()方法，可以将合约里的资金转移到指定账户： function transferTo(address account) public { account.transfer(this.balance); } 注意！transferTo()方法的当前实现，并没有限制调用者，因此任何人都可以调用该方法从而转走投票合约账户里的资金！在生产系统中，你必须添加一些限制条件来避免上面的资金漏洞，例如，检查目标账户是否在一个白名单里。 合约里面剩下的方法都是辅助性的getter方法，仅仅用来返回合约变量的值。 注意tokensSold()等方法声明中的constant修饰符，这表明该方法是只读的，即方法的执行 并不会改变区块链的状态，因此执行这些交易不会耗费任何gas。 4.5与之前类似，我们修改迁移脚本2_deploy_contracts.js来自动化投票合约的部署。 不过由于新的加权投票合约的构造函数声明了额外的参数，因此需要在迁移脚本中传入两个额外的参数 ： var Voting = artifacts.require(&quot;./Voting.sol&quot;); module.exports = function(deployer) { deployer.deploy(Voting, 10000, web3.toWei(&#39;0.01&#39;, &#39;ether&#39;), [&#39;Rama&#39;, &#39;Nick&#39;, &#39;Jose&#39;]); }; 在上面的代码中，我们部署的合约发行了10000个股票通证，单价为0.01以太。由于所有的价格需要以Wei为单位计价，所以我们需要用toWei()方法将Ether转换为Wei。 以太币面值 Wei 是 Ether 的最小面值。1 Ether 等于 1000000000000000000 Wei —— 18个0。 你可以把它当成是美分与美元，就像 Nickel（5 美分），Dime（10 美分），Quarter（25 美分），Ether 也有不同面值。其他面值如下： kwei/babbage mwei/lovelace gwei/shannon szabo finney ether kether/grand/einstein mether gether tether 当然也可以在 truffle 控制台，执行 web3.toWei(1, &#39;ether&#39;) 来看一下ether（或其他面值）与 wei 之间 的转换关系。例如： truffle(development)&gt; web3.toWei(1,&#39;ether&#39;) 现在可以编译合约并将其部署到区块链了： ~/repo/tkapp$ truffle compile Compiling Migrations.sol... Compiling Voting.sol... Writing artifacts to ./build/contracts ~/repo/tkapp$ truffle migrate Running migration: 1_initial_migration.js Deploying Migrations...Migrations: 0x3cee101c94f8a06d549334372181bc5a7b3a8bee Saving successful migration to network... Saving artifacts... Running migration: 2_deploy_contracts.js Deploying Voting...Voting: 0xd24a32f0ee12f5e9d233a2ebab5a53d4d4986203 Saving successful migration to network... Saving artifacts... 4.6成功地将合约部署到了ganache后，执行truffle console进入控制台，让我们和合约互动一下： 一个候选人（比如 Nick）有多少投票？ truffle(development)&gt; Voting.deployed().then(function(instance) {instance.totalVotesFor.call(&#39;Nick&#39;).then(function(i) {console.log(i)})}) 一共初始化发行了多少通证？ truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.totalTokens().then(function(v) {console.log(v)}))}) 已经售出了多少通证？ truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.tokensSold().then(function(v) {console.log(v)}))}) 购买 100个通证 truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.buy({value: web3.toWei(&#39;1&#39;, &#39;ether&#39;)}).then(function(v) {console.log(v)}))}) 购买以后账户余额是多少？ truffle(development)&gt; web3.eth.getBalance(web3.eth.accounts[0]) 已经售出了多少通证？ Voting.deployed().then(function(instance) {console.log(instance.tokensSold().then(function(v) {console.log(v)}))}) 给 Jose 投 25 个 通证，给 Rama 和 Nick 各投 10 个 通证。 truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.voteForCandidate(&#39;Jose&#39;, 25).then(function(v) {console.log(v)}))}) truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.voteForCandidate(&#39;Rama&#39;, 10).then(function(v) {console.log(v)}))}) truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.voteForCandidate(&#39;Nick&#39;, 10).then(function(v) {console.log(v)}))}) 查询你所投账户的投票人信息（除非用了其他账户，否则你的账户默认是 web3.eth.accounts[0]） truffle(development)&gt; Voting.deployed().then(function(instance) {console.log(instance.voterDetails(&#39;0x004ee719ff5b8220b14acb2eac69ab9a8221044b&#39;).then(function(v) {console.log(v)}))}) 现在候选人Rama有多少投票？ truffle(development)&gt; Voting.deployed().then(function(instance) {instance.totalVotesFor.call(&#39;Rama&#39;).then(function(i) {console.log(i)})}) 4.7现在，已经了解新的投票合约可以如约工作。现在开始构建前端逻辑，以便用户能够通过网页浏览器与合约交互。 以下可以自行参照git上的代码 HTML 如果仔细审查代码的话，你会发现网页中已经没有硬编码的值了。候选人的名字将通过向部署好的合约查询来进行填充。网页也会显示公司发行的股票通证总量，以及已售出和剩余的通证量。 Javascript 通过移除候选者姓名等等的硬编码，我们已经大幅改进了 HTML 文件。我们会使用javascript/web3js来填充 HTML页面里的所有值，并实现查询投票人信息的额外功能。 如果对 JavaScript 不太熟悉，这些代码可能略显复杂。那么最好先理解populateCandidates() 函数的实现。 实现帮助 创建一个 Voting 合约的实例 在页面加载时，初始化并创建 web3 对象。 创建一个在页面加载时调用的函数，它需要： 使用 Voting 合约对象，向区块链查询来获取所有的候选者姓名并填充表格。 再次查询区块链得到每个候选人所获得的所有投票并填充表格的列。 填充 token 信息，比如所有初始化的 token，剩余 token，已售出的 token 以及 token 成本。 实现 buyTokens 函数，它在上一节的 html 里面调用。你已经在控制台交互一节中购买了 token。buyTokens 代码与那一节一样不可或缺。 类似地，实现 lookupVoterInfo 函数来打印一个投票人的细节。 和之前一样，执行以下命令进行构建： ~/repo/tkapp$ webpack 然后进入build目录，启动轻量web服务器： ~/repo/tkapp/build$ python -m SimpleHTTPServer 如果一切顺利，你可以看到网页，可以输入一个账户地址（投票人的地址），观察他们的投票行为和股票通证数量的变化。 并且可以购买更多的股票通证，为任意候选者投票并查看投票人信息。 现在合约的实现方式，用户购买股票通证并用通证投票。但是他们投票的方式是向合约发送通证。如果他们必须在未来的 选举中投票怎么办？他们所有的通证都转移到了合约中！ 进一步改进合约的方式是，添加加入一个方法以便于用户能够在投票结束后拿回他们的通证。 五.总结到这里基本的教程介绍已经结束，虽说是入门级的DAPP开发，对于之前没有接触过的人来说，也是需要花点时间理顺和让代码跑起来的。投票系统这个案例可能会在很多入门教学中都会使用，所以如果需要跟人展示和交流的话，可能换一种场景会比较看上去高大上一点。如同开发手机APP一样，技术总是工具，真正产生价值的，更多是融入技术的思想。","tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://same4869.github.io/tags/blockchain/"}]},{"title":"Hexo博客重新起飞","date":"2018-02-18T16:00:00.000Z","path":"2018/02/19/Hexo博客重新起飞/","text":"开篇：好久没来这里倒腾了，意料之中地把hexo相关的东西忘了个精光，好在并没有浪费太多的时间，感觉还是有必要记录一下，以免浪费时间。环境：MACOS,已经有git了 1.安装node.js这个直接在网上搜一下官方就行了，或者点这里https://nodejs.org/en/download/ 2.安装hexosudo npm install hexo-cli -g 3.远程克隆项目eg: git clone https://github.com/ccflower/blogBackup.git 4.进入项目，安装HEXOnpm install hexo --save 5.项目HEXO初始化,安装依赖hexo init (这一步可能会有提示，需要用一个空目录init，然后再把所有东西考进去) npm install hexo s (这个就可以本地看了) 6.发布hexo g hexo d 参考文献：1.http://ccflower.space/2017/06/01/hexoBlog2.http://todd2010.github.io/2016/05/18/02-Hexo-GitHub/3.http://ryane.top/2018/01/10/2018%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%BA%86%EF%BC%81/","tags":[{"name":"otherTec","slug":"otherTec","permalink":"http://same4869.github.io/tags/otherTec/"}]},{"title":"《东京女子图鉴》碎碎念","date":"2017-12-24T16:00:00.000Z","path":"2017/12/25/东京女子图鉴/","text":"前序：前段时间在头条上就看到了这部日本网剧的推荐，过了好一阵子才想起来刷了一把。总共11集每集20分钟左右，虽说是电视剧其实总时长加起来都不如人家一个国外电影。但是内容却毫不拖沓地讲述了女主角从20岁到40岁这20年来在东京打拼的方方面面。这篇文章并不是影评，影评观点剧情介绍可能筛选自豆瓣上其他网友的影评，这里更多的是一些个人感悟和一些碎碎念，毕竟指望一本书一部剧或者一件事就改变人生观也是太不现实，在这些里面开阔眼界，优化思维，积累沉淀，就像剧中女主角那样，不断去接触自己坚持觉得好的东西，然后慢慢被其同化，自己也会变成那样的人。 1.剧情出身于外地（秋田县）的年轻姑娘绫，没有任何背景依靠，也没有名校学历和留学资历，为着一定要在东京出人头地（进入上流社会）的梦想，自己一个人在东京努力打拼，从二十岁到四十岁，住遍了东京从低档到高级社区的不同区域，也经历了不同身份和阶层的男性，最终，她在表面上达成了自己青春年少时的梦想，但实际上并没有，她的欲望会随着她所拥有的以及周围环境而不断改变，所谓的实现梦想，也只是像西西弗斯一样一遍一遍地推巨石一般。二十年后当绫回到故乡风轻云淡地准备自我释然时，曾经的老师拿着印有绫专访的那本杂志和一次插肩从新点燃了她对未来更高追求的欲望。是啊，未来应有尽有，未来一无所有。这个情节，据说多多少少得到了在北上广打拼的青年男女的共鸣。绫身上表现出来的运气，机遇以及对内心欲望的不断坚持，说明她是一个不断在思考和执行的聪明人，相信相同条件下的大多数普通人整个过程不会比这更乐观。 2.男人绫的每一个阶段都对应着一个男人，要么男友，要么情夫，要么老公，要么小白脸。可能有些人觉得绫太过绿茶婊，其实里面的男人充其量只是一个符号，是绫内心欲望的一个实体投影罢了，这样想是不是女主就正派多了，恩，其实就是绿茶婊。 『A. 三茶与同乡的男人』 初到东京，女主绫一心追求时尚地段的住所。她先后去了南青山、吉祥寺和下北泽看房。这些区域或是日系潮牌店扎堆，或是常年上榜年轻人最想居住街区，车站附近的房子都超出了预算。节节败退后，心气高的绫被磨了棱角，此时中介推荐了三茶。 入住三茶的绫甚至很快收获了一个住在同片街区、同乡的同事男友。同乡意味着共同的成长环境与话题，同街区意味着阶级与消费水平相当，同事意味着工作能力与水准也相当。在其他女同事们都在联谊攀高枝的同时，她已经和门当户对的男友过上了普通而幸福的小日子。 男人收获一份稳定的情感，女人开始在都市里有了立足之地。两个人在大都市的角落里相互取暖。一开始，确实是有点小幸福的。 只是伴随着绫工作上的晋升，两人关系开始失衡。普通的男友只能给予绫普通的幸福。而普通的幸福，随处都是，家乡也有。 于是绫推开普通男友的怀抱，逃离了普通的三茶。 『B.惠比寿与不婚的男人』 在2016年东京最宜居区域的排行榜上，惠比寿反超蝉联多年的吉祥寺夺得榜首。妆容精致的年轻女人走在惠比寿花园广场上，擦肩而过时暗自攀比彼此男伴。 这里有Joel Robuchon Restaurant，一家知名米其林三星法式餐厅，三十岁前能在这里约会就可以证明是好女人的餐厅。 约会在了惠比寿。居住在了惠比寿。交往了一个惠比寿的富二代男友。绫的轻熟女之路意气风发，即便男友声称是不婚主义也大度理解，幸福的最后一块拼图就是期待已久的Joel Robuchon生日约会。 在这段关系里，曾经绫和男友也是各取所需的平衡式。她需要家境阔绰的男友提携阶级，男友需要工作光鲜的女强人陪衬左右。然而当一方权衡进阶的砝码时，平衡再次被打破。这一次，被落下的是绫。 一夜之间幸福崩塌，盛装赴宴被放了大雕，不婚主义的男友已有未婚妻，还是个条件不如自己的普通女人。绫怅然若失。然而需要稳定的婚姻关系以提升社会公众形象的男人，和理想只是成为有钱人家的主妇且不介意未婚夫外遇的女人，这不过是一道新的平衡式。 爱情失意，事业得意。生猛的小镇姑娘咬紧牙，两腿生风继续狂奔。 『C.银座与不伦的男人』 银座，一处闪耀着光芒与传说的繁华之所。 扬眉吐气跳槽到了世界名牌旗下，绫也告别了属于年轻人的聚集地，跃过了名为银座的龙门。银座的高档酒店成为她经常下榻的地点，而与之共同出入的男伴，也升级成为了家蕴厚实的银座吴服店老板。 这段关系从开始便已失衡。老板犹如从天而降的光源氏，以上流阶层方能享用的高端物质享受精心调教绫，从其脱胎换骨般的蜕变中获取满足感。绫亦同样欣喜于这位贵人的垂青，将其暗喻为长腿叔叔，感激其将自己推上银座视野的最高处。 突然一日，33岁的『紫姬』长大成人，调教的乐趣已然丧失。老板毫不留恋的抽手离去，或许已有新的调教人选。毕竟浮华银座，绫不会是他最后一个人偶。 老板云淡风轻，绫却恼羞成怒。原本该是自己潇洒放手，谁料反被将军，好似被抛弃的玩物。 『D.丰洲与买下高级公寓的男人』 女性生育的年龄是有限的。现实世界里哪有白马王子。所以需要尽快结婚。然后，丈夫人选只要30来岁、年薪千万、身高175就合格。 以此视为新阶段的工作目标，从失恋打击中迅速爬起的女强人绫圆满完成了任务。其貌不扬没关系，符合条件就好。而且，这个男人说他支持女性的梦想。更何况，他还在37岁就买下了丰洲的高级公寓，那个位于东京湾岸线上的、作为高端人士聚集社区的丰洲的高级公寓。 男人需要一个可爱顾家的妻子，为此撒一点小谎又如何。女人需要一个体面的丈夫，为此对两人价值观的分歧睁只眼闭只眼又如何。 只要看似幸福就好了。毕竟两人年薪加起来有1700万呢。 曾与上司不屑的假面夫妻，转头来，自己也差点走到这一步。 『E.代代木上原的几个男人』 分居，离婚，同时与小鲜肉和成功人士交往。仿佛过山车一般，绫迅速摆脱了冰冷的丰洲高级公寓，住进了代代木上原。代代木上原是涉谷区的高档住宅区，环境优雅，绫认为这里的人们疏离而礼貌的生活着，与她当下想要追求的状态一致。 代代木上原篇是跨度最大的一个篇章。四个男人如蜻蜓点水般划过绫的生活：掉入无路可走的女下属陷阱的前夫，对未来毫不努力的小鲜肉，浑身堆砌名牌的港区男，以及十年前曾相互奚落过的毒舌男。 前夫渴求家庭型女人，正好女下属需要栖身之所，一颗扣子钓来一尾大鱼； 小鲜肉只想要活得轻松，正好女友人出身富贵，一块天价表抢来一只宠物； 港区男优越感爆棚，明示绫可在他婚后以情妇身份往来，仿佛给予施舍。他说，我出身港区，不会和港区之外的女人结婚。 这就是绫曾向往的东京的真相：出身阶级决定天花板。纵然看起来绫已经进阶成功，成为事业有成、有生活情趣的好女人，她依旧没法赢过好出身的女友人，也没法成为港区男的正妻候选。 无论再如何向上爬，她依旧只是小地方普通人家的女儿。那么一份普通的幸福，是不是更适合她呢？ 毒舌男问绫，你到现在还觉得东京闪闪发光吗？ 他看的太透，索性逃离了个干净。感谢编剧没有让这个角色和绫有过多纠缠，反倒成就了一抹亮色。 绫在世俗眼中的进阶之路上埋头打怪升级，一跑许多年，终于『砰』的一下，撞到了天花板上，不得已停下脚步，回望来时路。 【F. 东京与眼下陪伴的男人】 绫逃回故乡，复又重返东京，兜兜转转四十岁和知己搭伙过日子，自以为明了普通的幸福才是当下所求，却在某时某刻被一个擦肩而过再度撩起了内心的欲望。你以为这是一碗源于现实的鸡汤，谁料编剧在汤料里掺了毒。 生而为人，是忠于欲望前行一步，还是停在原地享受”这样就很好”的眼前幸福？绫粲然一笑，给出了她的选择，她的进阶之路也将继续下去。 欲望源于”I could be her”的设想，生活永远在别处。 ####3.搬家 在东京，女主搬了6次家。 第一次是三茶，房租便宜、生活便利，“年轻人最喜欢的街区”排名很靠前。这一年，她刚毕业，找到了第一份工作。 第二次是惠比寿，时尚小资，女孩们画着精致的妆容参加各种联谊活动。这一年，她甩掉了初恋，觉得自己值得拥有更好的。 第三次是银座，精致、高级，成熟的女性们自信的出入高级场所和写字楼。这一年，她去了薪酬更高的公司，做了高级情妇。 第四次是丰州，中产阶级聚集的高级公寓，到处都是太太团们互相交流育儿经。这一年，她工作升职，选择了嫁给各方面都很稳定的普通男人。 第五次是代代木上原，自由、独立，单身的女性们有各种生活情趣去满足自己。这一年，她与无爱的丈夫离婚，与咖啡馆的服务生小鲜肉成了炮友。 第六次是房龄20年的二手公寓，但这次女主把它买下来了。这一年，她与相识十几年的男闺蜜同居了，“因为再也不用担心会孤独终老了”。 这是一个不甘平庸的小镇女孩在大城市追求幸福和稳定的人生轨迹，可惜到最后她只得到了稳定，却没有获得幸福，因为她需要的幸福感是由欲望组成的，而欲望，是填不满的。 3.幸福感在这11集浓缩的20年里，女主表达了3次“幸福感”。 第一次是与同乡男的相濡以沫，日子过得苦，但是一起吃着泡面嬉笑着看电视，下班挽着手散步回家，拥挤的小床上互相温存，她觉得当下的这种平淡是幸福。 第二次是与住在惠比寿的商务精英男约会，在向往的高档餐厅门口，男友答应她之后在这里为她庆祝生日，想到前辈对她说过的“30岁之前能在这个餐厅约会就是好女孩”，这片刻的虚荣她觉得是幸福。 第三次是与事业稳定但没有责任心的丈夫决定用生育去填补婚姻的空白，同样是挽手散步看月亮，但这种组建家庭的完整让她觉得幸福。 可惜的是这些幸福感都转瞬即逝，当女主“大彻大悟”后重新去找同乡男的时候，只是久久地四目相对并说不出什么更多的话，而打破沉寂的是同乡男女儿叫爸爸的声音。女主应该没想过后悔，只是心里也有五味陈杂的感觉吧。 4.后记作为还在北上广深打拼大军中的一员，自己包括周围的人都常常不自觉地焦虑。内心的欲望，人生的目标，总是需要时间来实现，在实现的过程从，却又衍生出来更多的欲望，更大的目标，自然而来的是更大的压力。绫给我们演绎的是她对欲望地态度和每时每刻的心态，其实对于我们来说，绫真的是非常幸运的，每个目标都能那么顺利完成，只是即便如此，还是喂不饱内心的那头洪水猛兽，也许在高度文明的城市化社会体系里面，这头猛兽本身就不是我们自己能够控制的。一千个人能看出一千个不同的哈姆雷特，关于剧情的寓意无法过度解读只能按需索取。我们需要时刻注意到能让我们内心起波澜和平静的东西，然后不断地反思，总结，在反思，再总结，这种积累所沉淀下来的东西，才是真正的收获，慢慢养成习惯化作性格，学会慢慢控制心里的猛兽，可能幸福就会离你更近吧。 5.参考影评 https://movie.douban.com/review/8413541/https://movie.douban.com/review/8342386/https://movie.douban.com/review/8394470如有侵权，联系删除，谢谢","tags":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://same4869.github.io/tags/个人随笔/"}]},{"title":"《APP技术封装与选择》总览","date":"2017-12-18T16:00:00.000Z","path":"2017/12/19/《APP技术封装与选择》总览/","text":"虽然之前准备写得是《Android技能树探索》系列，但发现自己比较关注的还是实际的业务开发能力与效率问题，与其说《Android技能树探索》是从理论上的一次知识体系建立，那么这个系列可能更加关注实际中从0到1的APP业务开发与架构所需要的一些知识体系。当然本来没有好坏之前，拿出来区别是因为可能在这之中会有很多知识点上的重复，权当说明一下。 1. 当需要从0开始做一个APP时，我们该做什么？不管是从正常项目开发流程还是软件工程的视角来看，在做一个新的APP需要做的并不是新建一个工程，你可能需要先了解你的需求，和产品撕逼，熟悉应用整体逻辑，然后确定具体交互，精细到每个页面上的每个按钮，和UI要对视觉，和后台要定义接口，然后自己或者组内进行工作量评估，排期，等这些东东全部搞定了的时候，才能默默打开AS，新建一个项目。而我们需要讨论的东西，就是从新建一个项目后开始。 2. 快速开发，让从0开始，并不是真正从0开始很多同学应该都知道，我们平时在写软件的时候，总是在强调要低耦合，可扩展，要模块化，组件化。这一方面是为了代码的逻辑清晰，另一方面就是为了可移植和可复用了。打个不是很恰当的比方，APP是人写出来的，人和人虽然不一样，但是都有眼睛鼻子嘴巴四肢五脏六腑，APP也是一样，虽然每个APP看上去功能不一，但是一个比较完备的点APP一般都具有网络请求，图片加载，列表展示，分享等等的常用功能。所以快速开发的精髓，就是把这些功能都独立化，模块化，写好备用，APP需要的时候，直接拿来主义，绝对屡试不爽。 3. APP的技术封装与选择前面叨叨了这么多，那么接下来的问题是要把这些“眼睛”“鼻子”“嘴巴”都找出来，然后把它们做出来，最后拼在一起。或者换一句话说，当我们需要从0开始做一个APP的时候，我们应该考虑到这些。下图是以个人经验撸出来的一个脑图，感觉包含了大部分APP开发的通用问题，如有补充欢迎告知。 4. 看图说话结合上面的那张图，大致来捋一下这张图分为必要和可选，必要是基本上一个正常点的稍微大的APP都会具备的功能，除非自己弄个hello world玩儿，可选的是指到目前为止，都属于可选技术，APP中占比不是那么太高，当然都是出自个人主观判断，没有经过调查和数据分析。先看必要吧，包括有网络框架封装，图片加载框架封装，数据库封装，SP封装，权限封装，异常捕获和日志封装，主体架构选择，基本常用工具类，各种基类设计，开发规范。可选的有扩展语言选择，多进程支持，主题切换，插件化，热修复，第三方UI框架，打包相关，升级分享及第三方封装，页面路由，其他额外项。本来想把每一条在进一步理一遍的，不过看起来又是一个不小的工作量，不过本系列的下一步也是非常明确的了，会把每个point都尽可能扩展开来，包括封装要点，框架选择，框架原理对比，总之能细就尽量细了。 5.总结基本上每个系列都是一个自己美好的愿望罢了，这个系列的整体就是希望能够熟悉了解市面上的各种方案与框架，能够快速集成起来满足老板或者其他人的需要，同时为自己节省大量的时间，省得到时候再感叹书到用时方恨少就晚了，多的时候玩玩儿王者农药也是好的。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《精通Python网络爬虫》读书笔记","date":"2017-10-18T16:00:00.000Z","path":"2017/10/19/《精通Python网络爬虫》读书笔记/","text":"虽然是JD打折的时候买的实体书，但是近300页的技术书最后基本能够看完还是感觉挺不容易的。本书还是比较合胃口的，有基础但不限于乏味的独立知识点，有框架介绍也有侧重点，而且从0开始实战什么的才是技术书读者的最爱。书可能看完了就丢在一边了，后面也很难再次翻起，这里记录一些point，也方便以后查阅。 1.Urllib库与URLError异常处理1.1 爬取网页，基本指令导入 import urllib.request爬取一个网页 file = urllib.request.urlopen(&quot;http://www.baidu.com&quot;)打印输出 print(data)读取内容 file.read() 读取所有内容，返回字符串 file.readlines() 读取所有内容，返回列表变量 file.readline() 读取一行内容打开文件 fhandle = open(path, &quot;wb&quot;)写入文件 fhandle .write(data)关闭文件 fhandle .close()举个栗子 import urllib.request url = &quot;http://blog.csdn.net/chunqiuwei/article/details/74079916&quot; data = urllib.request.urlopen(url) fhandle = open(&quot;/Users/xunwang/Desktop/python/Demo1.2.html&quot;, &quot;wb&quot;) fhandle.write(data.read()) fhandle.close() 爬取网页直接写入文件 urllib.request.urlretrieve(url, path)清除urlretrieve产生的缓存 urllib.request.urlcleanup()返回相关信息 file.info()返回状态码 file.getcode()返回当前爬的url file.geturl()文本编码 urllib.request.quote()文本解码 urllib.request.unquote() 1.2 浏览器模拟，Headers属性有时候爬虫会返回403错误，这时候可以尝试在header中设置User-Agent来假装是浏览器。方法1，使用build_opener()修改报头 import urllib.request url = &quot;http://blog.csdn.net/chunqiuwei/article/details/74079916&quot; headers = (&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;) opener = urllib.request.build_opener() opener.addheaders = [headers] data = opener.open(url).read() print(data) 方法2，使用add_header()添加报头 import urllib.request url = &quot;http://blog.csdn.net/chunqiuwei/article/details/74079916&quot; req = urllib.request.Request(url) req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;) data = urllib.request.urlopen(req).read() print(data) 1.3 超时设置 import urllib.request for i in range(1,100): try: file = urllib.request.urlopen(&quot;https://myst729.github.io&quot;, timeout = 1) data = file.read() print(len(data)) except Exception as e: print(&quot;出现异常 --&gt; &quot; + str(e)) 1.4 HTTP协议请求 1.4.1 GET请求 import urllib.request keywd = &quot;hello&quot; url = &quot;http://www.baidu.com/s?wd=&quot; + keywd req = urllib.request.Request(url) data = urllib.request.urlopen(req).read() print(data) 如果出现中文的参数，那么使用urllib.request.quote()编码了再拼上去。 1.4.2 POST请求 import urllib.request import urllib.parse url = &quot;http://www.iqianyue.com/mypost/&quot; postdata = urllib.parse.urlencode({ &quot;name&quot;:&quot;ceo@iqianyue.com&quot;, &quot;pass&quot;:&quot;123456&quot; }).encode(&quot;utf-8&quot;) req = urllib.request.Request(url,postdata) req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;) data = urllib.request.urlopen(req).read() fhandle = open(&quot;/Users/xunwang/Desktop/python/Demo1.4.html&quot;, &quot;wb&quot;) fhandle.write(data) fhandle.close() 1.5 代理服务器设置使用作者提供的网址http://yum.iqianyue.com/proxy 去查询最新的代理IP def use_proxy(proxy_addr, url): import urllib.request proxy = urllib.request.ProxyHandler({&#39;http&#39;:proxy_addr}) opener = urllib.request.build_opener(proxy, urllib.request.HTTPHandler) # headers = (&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;) # opener.addheaders = [headers] urllib.request.install_opener(opener) #安装全局opener data = urllib.request.urlopen(url).read().decode(&quot;utf-8&quot;) return data proxy_addr = &quot;121.31.101.150:8123&quot; data = use_proxy(proxy_addr, &quot;http://www.baidu.com&quot;) print(len(data)) 1.6 异常处理URLError 一般错误汇总200 正常301 重定向到新的url，永久302 重定向到临时url，非永久304 请求资源未更新400 非法请求401 请求未经授权403 禁止访问404 没找到页面500 服务器内部错误501 服务器不支持实现请求所需功能 一般产生URLError原因可能为1.连接不上服务器2.远程URL不存在3.无网络4.触发了HTTPError(即上面错误码的那些)一般先用子类处理，处理不了交给父类 import urllib.request import urllib.error try: urllib.request.urlopen(&quot;http://www.baiduss.com&quot;) except urllib.error.HTTPError as e: print(e.code) print(e.reason) except urllib.error.URLError as e: if hasattr(e, &quot;code&quot;): print(e.code) if hasattr(e, &quot;reason&quot;): print(e.reason) 2.正则表达式与cookie的使用一般使用re模块实现python正则表达功能。 2.1 原子 2.1.1 普通字符作为原子比如数字，大小写字母，下划线等 import re pattern = &quot;yue&quot; string = &quot;http://yum.iqianyue.com&quot; result = re.search(pattern, string) print(result) 运行结果 &lt;_sre.SRE_Match object; span=(16, 19), match=&#39;yue&#39;&gt; 2.1.2 非打印字符作为原子比如\\n，\\t 2.1.3 通用字符作为原子\\w 匹配任意一个字母，数字或者下划线\\d 匹配任意一个十进制数\\s 匹配任意一个空白字符以上的大写形式都是匹配对应的补集 import re pattern = &quot;\\w\\dpython\\w&quot; string = &quot;abcdfphp345pythony_py&quot; result = re.search(pattern, string) print(result) 2.1.4 原子表[]中括号括起来的里面的原子具有相同的地位，只要有里面一个能够匹配成功，就算匹配成功。[^]代表除了括号里的原子外其他均可以匹配 import re pattern1 = &quot;\\w\\dpython[xyz]\\w&quot; pattern2 = &quot;\\w\\dpython[^xyz]\\w&quot; pattern3 = &quot;\\w\\dpython[xyz]\\W&quot; string = &quot;abcdfphp345pythony_py&quot; result1 = re.search(pattern1, string) result2 = re.search(pattern2, string) result3 = re.search(pattern3, string) print(result1) print(result2) print(result3) 运行结果 &lt;_sre.SRE_Match object; span=(9, 19), match=&#39;45pythony_&#39;&gt; None None 2.2 元字符 . 匹配除换行符外的任意字符 import re pattern1 = &quot;.python...&quot; string = &quot;abcdfphp345pythony_py&quot; result1 = re.search(pattern1, string) print(result1) 运行结果 &lt;_sre.SRE_Match object; span=(10, 20), match=&#39;5pythony_p&#39;&gt; ^ 匹配字符串的开始位置 import re pattern1 = &quot;^abd&quot; pattern2 = &quot;^abc&quot; pattern3 = &quot;py$&quot; pattern4 = &quot;ay$&quot; string = &quot;abcdfphp345pythony_py&quot; result1 = re.search(pattern1, string) result2 = re.search(pattern2, string) result3 = re.search(pattern3, string) result4 = re.search(pattern4, string) print(result1) print(result2) print(result3) print(result4) 运行结果 None &lt;_sre.SRE_Match object; span=(0, 3), match=&#39;abc&#39;&gt; &lt;_sre.SRE_Match object; span=(19, 21), match=&#39;py&#39;&gt; None $ 匹配字符串的结束位置 * 匹配0次，1次或多次前面的原子 ? 匹配0次，1次前面的原子 + 匹配1次，多次前面的原子 {n} 前面的原子恰好出现n次{n,} 前面的原子至少出现n次{n,m} 前面的原子至少出现n次，至多出现m次 import re pattern1 = &quot;py.*n&quot; pattern2 = &quot;cd{2}&quot; pattern3 = &quot;cd{3}&quot; pattern4 = &quot;cd{2,}&quot; string = &quot;abcddddfphp345pythony_py&quot; result1 = re.search(pattern1, string) result2 = re.search(pattern2, string) result3 = re.search(pattern3, string) result4 = re.search(pattern4, string) print(result1) print(result2) print(result3) print(result4) 运行结果 &lt;_sre.SRE_Match object; span=(14, 20), match=&#39;python&#39;&gt; &lt;_sre.SRE_Match object; span=(2, 5), match=&#39;cdd&#39;&gt; &lt;_sre.SRE_Match object; span=(2, 6), match=&#39;cddd&#39;&gt; &lt;_sre.SRE_Match object; span=(2, 7), match=&#39;cdddd&#39;&gt; | 模式选择符选择符中的任意一边满足就行 import re pattern1 = &quot;python|php&quot; string = &quot;abcdddphpdfphp345pythony_py&quot; result1 = re.search(pattern1, string) print(result1) 运行结果 &lt;_sre.SRE_Match object; span=(6, 9), match=&#39;php&#39;&gt; () 模式单元符()中的原子组成一个大原子 import re pattern1 = &quot;(cd){1,}&quot; pattern2 = &quot;cd{1,}&quot; string = &quot;abcdddphpdfphp345pythony_py&quot; result1 = re.search(pattern1, string) result2 = re.search(pattern2, string) print(result1) print(result2) 运行结果 &lt;_sre.SRE_Match object; span=(2, 4), match=&#39;cd&#39;&gt; &lt;_sre.SRE_Match object; span=(2, 6), match=&#39;cddd&#39;&gt; 2.3 模式修正 I 匹配时忽略大小写M 多行匹配L 做本地化识别匹配U 根据Unicode字符及解析字符S 让.匹配包括换行符，即用了该模式修正符后，”.”匹配就可以匹配任意字符了 import re pattern1 = &quot;python&quot; pattern2 = &quot;python&quot; string = &quot;abcdddphpdfphp345Pythony_py&quot; result1 = re.search(pattern1, string) result2 = re.search(pattern2, string, re.I) print(result1) print(result2) 运行结果 None &lt;_sre.SRE_Match object; span=(17, 23), match=&#39;Python&#39;&gt; 2.4 贪婪模式与懒惰模式贪婪模式就是尽可能多的匹配，懒惰模式就是尽可能少的匹配。 import re pattern1 = &quot;p.*y&quot; pattern2 = &quot;p.*?y&quot; string = &quot;abcdddphpdfphp345Pythony_py&quot; result1 = re.search(pattern1, string) result2 = re.search(pattern2, string) print(result1) print(result2) 运行结果 &lt;_sre.SRE_Match object; span=(6, 27), match=&#39;phpdfphp345Pythony_py&#39;&gt; &lt;_sre.SRE_Match object; span=(6, 19), match=&#39;phpdfphp345Py&#39;&gt; 2.5 正则表达式常见函数2.5.1 re.match()和re.search() import re string = &quot;hellomypythonhispythonourpythonend&quot; pattern = &quot;.python.&quot; result = re.match(pattern, string) result2 = re.search(pattern, string) print(result) print(result2) 运行结果 None &lt;_sre.SRE_Match object; span=(6, 14), match=&#39;ypythonh&#39;&gt; match函数是从源字符串的开头进行匹配，而search函数会在全文中进行匹配 2.5.2 全局匹配函数使用re.complie()预编译，再使用ffindall()找出全部结果 import re string = &quot;hellomypythonhispythonourpythonend&quot; pattern = re.compile(&quot;.python.&quot;) result = pattern.findall(string) # pattern = &quot;.python.&quot; # result = re.compile(pattern).findall() print(result) 运行结果 [&#39;ypythonh&#39;, &#39;spythono&#39;, &#39;rpythone&#39;] 2.5.3 re.sub()函数使用正则来实现替换功能 import re string = &quot;hellomypythonhispythonourpythonend&quot; pattern = &quot;.python.&quot; result1 = re.sub(pattern, &quot;php&quot;, string) #全部替换 result2 = re.sub(pattern, &quot;php&quot;, string, 2) #替换两次 print(result1) print(result2) 运行结果 hellomphpiphpuphpnd hellomphpiphpurpythonend 2.6 cookie2.6.1维持会话状态的常用方式一般为两种，cookie和session。如果是cookie，登录后会把会话信息保存在客户端，重新访问时会从本地cookie中读取对应的会话信息，从而判断目前的会话状态。如果是session，会话信息保存在服务端，服务端会给客户端发一个sessionId，这个信息保存在cookie中（如果本地禁用cookie，可能保存在其他地方）。重新访问时，根本本地信息发送至服务端检索出对应的会话状态。 2.6.2进行cookie处理的一种常用思路如下：1.导入Cookie处理模块http.cookiejar2.使用http.cookjar.CookJar()创建CookieJar对象。3.使用HTTPCookieProcessor创建cookie处理器，并以其为参数构建opener对象。4.创建全局默认的opener对象。 import urllib.request import urllib.parse import http.cookiejar #这个地址是在network中监控的真实提交表单的地址 url = &quot;http://bbs.chinaunix.net/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;loginhash=LApSM&quot; postdata = urllib.parse.urlencode({ &quot;username&quot;:&quot;same4869&quot;, &quot;password&quot;:&quot;58129553&quot; }).encode(&#39;utf-8&#39;) req = urllib.request.Request(url, postdata) req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;) #使用http.cookiejar.CookieJar()创建CookieJar对象 cjar = http.cookiejar.CookieJar() #使用HTTPCookieProcessor创建cookie处理器，并以其为参数构造opener opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cjar)) #安装为全局opener urllib.request.install_opener(opener) file = opener.open(req) data = file.read() file = open(&quot;/Users/xunwang/Desktop/python/Demo1.5.html&quot;, &quot;wb&quot;) file.write(data) file.close() url2 = &quot;http://bbs.chinaunix.net/forum.php&quot; data2 = urllib.request.urlopen(url2).read() fhandle = open(&quot;/Users/xunwang/Desktop/python/Demo1.5.1.html&quot;, &quot;wb&quot;) fhandle.write(data2) fhandle.close() 3.手写Python爬虫","tags":[{"name":"otherTec","slug":"otherTec","permalink":"http://same4869.github.io/tags/otherTec/"}]},{"title":"commlib使用指南","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/commlib使用指南/","text":"一般来说重新开发一个项目都会有很多重复劳动，一些底层非业务的东西也总是大同小异，这几年看到的项目一般都是有个comm之类的lib，特点就是业务无关，通用性强，使用方便等等。网上也不乏有很多快速开发的框架，但是建议还是把日常积累的东西整理成一个自己的专属lib，不仅可以达到学习的目的，而且扩展性和熟悉程度都是不言而喻的，这个项目希望能够持续扩展，本篇文章也权当一个索引和使用指南了。 1.概况本项目属于开源项目，git地址：https://github.com/same4869/XwangCommLib然后这个项目已经上传上jcenter上面，所以任何项目想要使用里面的内容只需要在gradle里面添加compile &#39;com.xwang:commlib:1.0.0&#39;就行了，最后一个是版本号，最新的版本号请查看最新的git log。此外如果自己想把自己封装的lib上传到jcenter请查看 https://gold.xitu.io/entry/58992a452f301e00697a17b9 这篇博文。 2.索引2.1 CommCountDownTimer和5.0以上的CountDownTimer源码完全一致，大概对比了一下，应该是解决低版本倒计时cancel可能出现的问题。倒计时控件，使用方式大概如下 new CommCountDownTimer(30000, 1000) { public void onTick(long millisUntilFinished) { mTextField.setText(&quot;seconds remaining: &quot; + millisUntilFinished / 1000); } public void onFinish() { mTextField.setText(&quot;done!&quot;); } }.start(); 2.2 CommThreadPool里面包含一个基于newCachedThreadPool的线程池，还包含一个HandlerThread和一个主线程的Handler。暴露了3个方法出来poolExecute(Runnable runnable)，使用线程池，一般耗时方法采用这个方法使用线程池管理。serialExecute(Runnable runnable)，使用HandlerThread创建的固定线程。runOnUiThread(Runnable runnable)，主线程中运行。使用大概如下 WenbaThreadPool.poolExecute(new Runnable() { @Override public void run() { ... } }); 2.3 SharedSetting这个组件主要解决多应用间存储共享的问题，使用ContentProvider来实现，封装后可以像使用SP一样存储和读取多应用间的共享数据。使用方式如下 2.3.1多应用中必须有且仅有一个应用（一般是主应用，其他应用使用的时候保证这个应用必须已经安装）在AndroidManifest.xml中声明 &lt;provider android:name=&quot;commlib.xun.com.commlib.sharedsetting.CommSharedSettingContentProvider&quot; android:authorities=&quot;commlib.xun.com.commlib.sharedsetting.CommSharedSettingContentProvider&quot; android:exported=&quot;true&quot;/&gt; 2.3.2在需要使用此功能的APP中建立SharedSetting类，里面跟封装的SP规则差不多 public class SharedSetting { private static final String TEST_OH = &quot;test_oh&quot;; public static void setSavedPenAddress(String address) { CommSharedSettingOperator.save(SameMvpApplicationContext.application, TEST_OH, address, null); } public static String getSavedPenAddress() { return CommSharedSettingOperator.queryValue(SameMvpApplicationContext.application, TEST_OH); } } 2.3.3存储使用如下 SharedSetting.setSavedPenAddress(&quot;我来自SameMvpDemo&quot;); 读取使用如下 SharedSetting.getSavedPenAddress() 2.4 CommMultiThreadAsyncTask继承自AsyncTask，用法也一致，其中暴露了executeMultiThread方法，会在API 11以上使用之前CommThreadPool里面所创建的线程池，然后也暴露出了poolExecute方法，和CommThreadPool的方法一致。使用如下 new CommMultiThreadAsyncTask&lt;Void, Void, HomeWork&gt;() { protected void onPreExecute() { } @Override protected HomeWork doInBackground(Void... params) { } @Override protected void onPostExecute(HomeWork result) { } }.executeMultiThread(); 当然也可以继承CommMultiThreadAsyncTask来进行进一步的封装。 2.5 CommWeakHandlerCommWeakHandler主要是用来解决日常中使用handler带来的内存泄露问题，用法跟普通的handler一样用就行了，主要要声明成全局和activity一个生命周期 private WeakHandler mHandler = new WeakHandler(); 了解原理请移步git地址https://github.com/badoo/android-weak-handler在谷歌上搜索WeakHandler会用不少分析文章。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《APP研发录》读书笔记","date":"2017-08-20T16:00:00.000Z","path":"2017/08/21/APP研发录/","text":"前言：这篇是很早以前看《APP研发录》的读书笔记，也是很长一段时间唯一能看完一本并还能留下点东西的技术书籍。最近在整理越来越多的印象笔记，感觉只有不断地输出和写作才能营造出消化了部分的假象，为了让万事开头难更加简单，还是得坚持啊科科。 第一部分 高效框架设计与重构 重构相关 包结构相关 每个文件只有一个单独的类，不要有嵌套类，比如在Activity中嵌套Adapter、Entity。 以上为一级分包样例参考，如涉及到具体模块，可以再继续分包 单一职责的定义是：一个类或方法，只做一件事情。 设置BaseAcivity，重新定义生命周期，规范化整体风格 public abstract class BaseActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); initVariables(); initViews(savedInstanceState); loadData(); } protected abstract void initVariables(); protected abstract void initViews(Bundle savedInstanceState); protected abstract void loadData(); } 不建议在onClick里面写过多逻辑，建议抽成方法，让onClick简洁。 与服务器的数据交流不建议使用自带的JSONObject，会出现序列化和代码不简洁的问题，建议使用fastJson,Gson等等，注意混淆时该Keep的地方。 不要使用类间的全局变量，因为随时可能因为内存不足被系统回收，非要使用的话需要本地化这些值作保证。 类型转换建议在公共util类里面设置相应的安全方法，例如 public final static int convertToInt(Object value, int defaultValue) { if (value == null || &quot;&quot;.equals(value.toString().trim())) { return defaultValue; } try { return Integer.valueOf(value.toString()); } catch (Exception e) { try { return Double.valueOf(value.toString()).intValue(); } catch (Exception e1) { return defaultValue; } } } 时时刻刻注意空值，越界等异常的捕获与处理，永远不要相信服务器或者外部传过来的数据的合法性。 底层网络框架设计 如果自己写网络框架，使用AsyncTask居多，一般写法如下```Overrideprotected Response doInBackground(String… url) {return getResponseFromURL(url[0]);}private Response getResponseFromURL(String url) {Response response = new Response();HttpGet get = new HttpGet(url);String strResponse = null;try { HttpParams httpParameters = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(httpParameters, 8000); HttpClient httpClient = new DefaultHttpClient(httpParameters); HttpResponse httpResponse = httpClient.execute(get); if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { strResponse = EntityUtils.toString(httpResponse.getEntity()); }} catch (Exception e) { response.setErrorType(-1); response.setError(true); response.setErrorMessage(e.getMessage());}if (strResponse == null) { response.setErrorType(-1); response.setError(true); response.setErrorMessage(“网络异常, 返回空值”);} else { strResponse = “{‘isError’:false,’errorType’:0,’errorMessage’:’’, ‘result’:{‘city’:’北京’,’cityid’:’101010100’,’temp’:’17’, ‘WD’:’西南风’,’WS’:’2级’,’SD’:’54%’,’WSE’:’2’,’time’:’23:15’, &#39;isRadar&#39;:&#39;1&#39;,&#39;Radar&#39;:&#39;JC_RADAR_AZ9010_JB&#39;, &#39;njd&#39;:&#39;暂无实况&#39;,&#39;qy&#39;:&#39;1016&#39;}}&quot;; response = JSON.parseObject(strResponse, Response.class); }return response;} public abstract class RequestAsyncTask extends AsyncTask { public abstract void onSuccess(String content); public abstract void onFail(String errorMessage); @Override protected void onPreExecute() { } @Override protected void onPostExecute(Response response) { if(response.hasError()) { onFail(response.getErrorMessage()); } else { onSuccess(response.getResult()); } } - 至少两个地方可以优化： 1. 使用线程池 2. 支持实时取消 3. 一些回调可以抽出公共默认动作 - 书中介绍了一种ThreadPoolExecutor+Runnable+Handler的写法 &gt;源码参见http://www.cnblogs.com/Jax/p/4656789.html &gt;其他东西也可以在这里找到源码就是了 - 优化接口访问速度，可以为每个接口定义一个缓存时间，在一定时间内还是使用上次的结果，而不是重新请求后台。尤其针对一些get方式的查询类请求。 - 缓存存在SD卡中，URL及参数作为KEY，数据作为值。 - 请求时，先查看缓存时间时候过期，未过期则找本地缓存，如果没有再请求，并把请求结果存本地，更新缓存时间，如果有直接返回。 - 记得设置一个强制立即更新的方法，以备不时之需。 - 如果后台接口还没好，可以考虑先定义字段，然后使用MockService，其实就是造假数据啦。 - 书上那个略复杂，其实在BaseBean里面设置`public abstract String getJsonData();`方法，然后再具体的Bean里面生成假数据返回回去就行啦。 - 登录逻辑一般分为3种： 1. 点击登录按钮，进入登录页面LoginActivity，登录成功后，直接进入个人中心PersonCenterActivity。这种情况最直截了当，一路执行startActivity(intent)就能达到目的。 2. 在页面A，想要跳转到页面B，并携带一些参数，却发现没有登录，于是先跳转到登录页，登录成功后，再跳转到B页面，同时仍然带着那些参数。 3. 在页面A，执行某个操作，却发现没有登录，于是跳转到登录页，登录成功后，再回到页面A，继续执行该操作。 @Override public void onSuccess(String content) { UserInfo userInfo = JSON.parseObject(content, UserInfo.class); if (userInfo != null) { User.getInstance().reset(); User.getInstance().setLoginName(userInfo.getLoginName()); User.getInstance().setScore(userInfo.getScore()); User.getInstance().setUserName(userInfo.getUserName()); User.getInstance().setLoginStatus(true); User.getInstance().save(); } if(needCallback) { setResult(Activity.RESULT_OK); finish(); } else { Intent intent = new Intent(LoginActivity.this, PersonCenterActivity.class); startActivity(intent); } } }; - 自动登录一般依赖于cookie(token)，一般存放在Http-Response的header中，APP端不关心里面内容，每次请求当参数传给服务器，每次获得应答则刷新cookie。 - APP判断用户是否登录则检查这个值就行。服务器来判断cookie是否过期。 - 出于安全考虑，登录API如果被某一IP频繁访问后端需要作出反应，APP端应该给予配合，比如需要输入验证码啥的，防止恶意注册。密码什么的一定不要用明文。 - 每次HTTP Response头的Date属性里面返回服务器真实时间，减去APP本地时间获得差值并保存，同时暴露接口获得这个值，在请求的时候可能会用到。 - 在HTTPRequest头中key是Accept-Encoding，value是gzip，可以开启Gzip压缩。 - MobileAPI的逻辑是，检查HTTP请求头中的Accept-Encoding是否有gzip值，如果有，就会执行gzip压缩。 如果执行了gzip压缩，那么在返回值也就是HTTPResponse的头中，有一个content-encoding字段，会带有gzip的值；否则，就没有这个值。 - App检查HTTPResponse头中的content-encoding字段是否包含gzip值，这个值的有无，导致了App解析HTTPResponse的姿势不同，如下所示（以下代码参见HTTPRequest这个类）： String strResponse = “”;if ((response.getEntity().getContentEncoding() != null) &amp;&amp; (response.getEntity().getContentEncoding() .getValue() != null)) { if (response.getEntity().getContentEncoding() .getValue().contains(“gzip”)) { final InputStream in = response.getEntity() .getContent(); final InputStream is = new GZIPInputStream(in); uest.inputStreamToString(is); is.close(); } else { response.getEntity().writeTo(content); strResponse = new String(content.toByteArray()).trim(); }} else { response.getEntity().writeTo(content); strResponse = new String(content.toByteArray()).trim();} ##### Android经典场景设计 1）简介ImageLoader。 地址：http://blog.csdn.net/yueqinglkong/article/details/27660107 2）Android-Universal-Image-Loader图片异步加载类库的使用（超详细配置）。 地址：http://blog.csdn.net/vipzjyno1/article/details/23206387 3）Android开源框架Universal-Image-Loader完全解析。 地址：http://blog.csdn.net/xiaanming/article/details/39057201 - 关于Fresco的更多介绍请参见： ·Fresco在GitHub上的源码：https://github.com/mkottman/AndroLua ·Fresco官方文档：http://fresco-cn.org/docs/index.html - 加载网络图片的时候，一定要看显示控件的大小，然后把要显示的图片缩放到相同等级的大小内再显示，尤其是列表的item那种，不然轻松OOM。 - 针对以上策略，需要一个工具类，传入需要的宽高，然后给出缩放后的图片（bitmap）。 - 以上缩放也可以服务器操作，服务器和APP还可以约定一个低流量模式(降低图片质量)与极速模式（基本无图），通过APP端的不同网络监听进行合理的切换。 - 城市列表设计，建议本地保存一份，带版本号，服务器根据APP端的版本号返回增删改的数据，APP端更新并保存。 - App操作HTML5页面的方法 1. HTML5 CallAndroidMethod 2. Android wvAds.getSettings().setJavaScriptEnabled(true);wvAds.loadUrl(“file:// /android_asset/104.html”);btnShowAlert.setOnClickListener(new View.OnClickListener() {@Overridepublic void onClick(View v) {String color = “#00ee00”;wvAds.loadUrl(“javascript: changeColor (‘“ + color + “‘);”); }}); - HTML5页面操作App页面的方法 1. HTML5 CallAndroidMethod 2. Android class JSInteface1 { public void callAndroidMethod(int a, float b, String c, boolean d) { if (d) { String strMessage = “-“ + (a + 1) + “-“ + (b + 1) + &quot;-&quot; + c + &quot;-&quot; + d; new AlertDialog.Builder(MainActivity.this) .setTitle(&quot;title&quot;) .setMessage(strMessage).show(); } }} 同时，需要注册baobao和JSInterface1的对应关系： wvAds.addJavascriptInterface(new JSInteface1(), “baobao”); 要在方法前增加@JavascriptInterface，否则，就不能触发JavaScript方法。 - 可以在APP的方法内加入参数，来让H5页面开发者能控制页面在APP内的跳转，之前需先约定好跳转的规则对应列表。 - 有时也可以使用H5来帮助做一些复杂的动画，比如在本地放一个HTML： 然后使用真实数据来替换 `&lt;data1DefinedByBaobao&gt;` - Native和H5由后台可配到底显示哪个页面，可能一些特定的需求会用到这个策略，先暂存。 ---- ##### Android命名规范和编码规范 - Java类文件命名规范 1. Activity命名规范：以Activity作为后缀。比如说PersonActivity。 2. Adapter命名规范：以Adapter作为后缀。比如说PersonAdapater。 3. Entity命名规范：大多以Entity作为后缀。比如说PersonEntity。（Bean） - 资源文件命名规范 1. 页面布局文件。以act_为前缀，以Activity所在的Package作为中缀，以Activity的名称（去掉Activity后缀）作为后缀。注意都是小写。 ·例如，对于Person这个模块下的AddCustomerActivity，它的layout文件就应该是：act_person_addcustomer.xml。 2. ListView中的item布局文件。以item_作为固定前缀，列表项的名称为后缀。注意都是小写。例如，某个页面下有一个用户列表，控件名为lvUserList，那么item的layout就应该是：item_lvUserList.xml。 3. Dialog布局文件。 以dlg_作为固定前缀，Dialog的功能名称为后缀。注意都是小写，例如：dlg_hint.xml。 - JAVA中的对象使用驼峰式，常量大写，控件id和string等用下划线式，多多强迫症，多多处女座。 - codeFormat最好所有人共用一份xml，以免格式化后git上一片红。 ------ #### 第二部分 App开发中的高级技巧 ----- ##### Crash异常收集与统计 - Crash分析三部曲 1. 收集：把Crash收集到本地数据库。 2. 统计：对每天线上大量的Crash进行去重、分类。 3. 分析：逐个分析各类Crash，重现异常发生的例子，给出解决方案。 - 使用UncaughtExceptionHandler收集异常，网上代码很多就不贴代码了，一般在handleException里面做三件事： 1. 错误日志到服务器。 2. 给用户崩溃前的友好提示。 3. 把错误日志记录到SD卡。 - 对服务器发送以下数据字段（参考） ![Alt text](/img/005/20170412-3.png) - 在具体的Activity中，我们会将CrashType设置为0，而在CrashHandler中才会将CrashType设置为1。 - 服务器要及时统计这些数据并分类去重后由高到低排序。 ----- ##### ProGuard相关 - 以下是混淆最基本的配置信息，任何App都要使用，可以作为模板使用，作者为每行代码都增加了注释： 代码混淆压缩比, 在0~7之间, 默认为5, 一般不需要改 -optimizationpasses 5 混淆时不使用大小写混合, 混淆后的类名为小写-dontusemixedcaseclassnames # 指定不去忽略非公共的库的类 -dontskipnonpubliclibraryclasses # 指定不去忽略非公共的库的类的成员 -dontskipnonpubliclibraryclassmembers # 不做预校验, preverify是proguard的4个步骤之一 # Android不需要preverify, 去掉这一步可加快混淆速度 -dontpreverify # 有了verbose这句话, 混淆后就会生成映射文件 # 包含有类名-&gt;混淆后类名的映射关系 # 然后使用printmapping指定映射文件的名称 -verbose -printmapping proguardMapping.txt # 指定混淆时采用的算法, 后面的参数是一个过滤器 # 这个过滤器是谷歌推荐的算法, 一般不改变 -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* 保护代码中的Annotation不被混淆这在JSON实体映射时非常重要, 比如fastJson-keepattributes Annotation 避免混淆泛型,这在JSON实体映射时非常重要, 比如fastJson-keepattributes Signature// 抛出异常时保留代码行号, 在第6章异常分析中我们提到过-keepattributes SourceFile,LineNumberTable - 然后加入需要保留不混淆的东西，示例如下： 保留所有的本地native方法不被混淆-keepclasseswithmembernames class * { native ; } 保留了继承自Activity、Application这些类的子类因为这些子类都有可能被外部调用比如说, 第一行就保证了所有Activity的子类不要被混淆-keep public class extends android.app.Activity-keep public class extends android.app.Application-keep public class extends android.app.Service-keep public class extends android.content.BroadcastReceiver-keep public class extends android.content.ContentProvider-keep public class extends android.app.backup.BackupAgentHelper-keep public class extends android.preference.Preference-keep public class extends android.view.View-keep public class com.android.vending.licensing.ILicensingService 如果有引用android-support-v4.jar包, 可以添加下面这行-keep public class com.tuniu.app.ui.fragment.* {;} 保留在Activity中的方法参数是view的方法,从而我们在layout里面编写onClick就不会被影响-keepclassmembers class extends android.app.Activity { public void (android.view.View);} 枚举类不能被混淆-keepclassmembers enum { public static *[] values(); public static valueOf(java.lang.String);} 保留自定义控件(继承自View)不被混淆-keep public class extends android.view.View { ** get(); void set(*); public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int);} 保留Parcelable序列化的类不被混淆-keep class implements android.os.Parcelable { public static final android.os.Parcelable$Creator ;} 保留所有的本地native方法不被混淆-keepclasseswithmembernames class * { native ;} 保留了继承自Activity、Application这些类的子类因为这些子类都有可能被外部调用比如说, 第一行就保证了所有Activity的子类不要被混淆-keep public class extends android.app.Activity-keep public class extends android.app.Application-keep public class extends android.app.Service-keep public class extends android.content.BroadcastReceiver-keep public class extends android.content.ContentProvider-keep public class extends android.app.backup.BackupAgentHelper-keep public class extends android.preference.Preference-keep public class extends android.view.View-keep public class com.android.vending.licensing.ILicensingService 如果有引用android-support-v4.jar包, 可以添加下面这行-keep public class com.tuniu.app.ui.fragment.* {;} 保留在Activity中的方法参数是view的方法,从而我们在layout里面编写onClick就不会被影响-keepclassmembers class extends android.app.Activity { public void (android.view.View);} 枚举类不能被混淆-keepclassmembers enum { public static *[] values(); public static valueOf(java.lang.String);} 保留自定义控件(继承自View)不被混淆-keep public class extends android.view.View { ** get(); void set(*); public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int);} 保留Parcelable序列化的类不被混淆-keep class implements android.os.Parcelable { public static final android.os.Parcelable$Creator ;} 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();} 对于R(资源)下的所有类及其方法, 都不能被混淆-keep class *.R$ { *;} 对于带有回调函数onXXEvent的, 不能被混淆-keepclassmembers class { void (*OnEvent);} ---- ##### 持续集成 - 关于git分支的流程，书中介绍了几种不同的方法与场景，比较值得认可的是主干开发，分支上线的一种策略。 - 主干开发，分支上线是在主干上开发新功能，测试阶段或者上个迭代没完成下个开发周期又开始的情况下，merge到分支上，留一部分人改bug或者开发遗留功能，另一部分在主干上开发新功能，分支上功能完成打包发版后合并到主干上。 - 分享一个以前在问问的时候代码提交流程：每个developer在专属自己的本地分支开发，非master成员（master成员才有资格把代码merge到主干分支）每次对master发送一个merge request而不是push，必须要master进行code review后由master合并代码。 - ant打包自行查阅 ![Alt text](/img/005/20170412-4.png) - 如果有Monkey包，可以在全局常量中设置isMonKey，还可以在N级页面中留暗门，来控制MonKey可达的页面。 ---- ##### App竞品技术分析 - APP打开速度优化关注点 1. 闪屏的下载策略 2. 引导动画的复杂度，引导页面的数量 3. 城市列表加载，城市定位 4. 首页的复杂度 5. 打点统计，推送，异常捕获的处理机制 6. 使用WireShark或者fiddler抓竞品包分析 - H5页面打开速度优化关注点 1. APP内放一个包含H5的ZIP包，首次启动解压，根据版本号判断，满足则加载本地。 2. 这个ZIP包可以是APP在适当位置下载的。 3. 可以使用增量包的形式，但要保证包不宜过大。 4. 开启webview缓存 5. 比较极端的做法，可以在上一个页面创建一个WebView，让它预先加载这个URL，这样就能提前把HTML5页面缓存到本地，一定要记住，要把这个WebView设置为不可见，否则就露馅了。 - APP大小优化关注点 1. 图片质量往往都是不必要的过大，一定要合理控制压缩，尤其超过1M的。 2. 音效，音频也应该选择合理比率和长度。 3. splash图片可以用jpg,其他的可以用png。 4. google的WebP格式图片尤其是安卓可以尝试。 5. 大图尽量使元素拆分。 6. 某些场景图标字体绝对是最佳解决方案。 7. 定期使用lint清理未使用的图片，当然还有代码中的各种不规范。 - APP网络请求性能优化关注点 1. 对于有多个线上服务器的，本地APP可以维护一个服务器列表，并自动选择最佳服务器。 2. 刚开的时候，遍历所有服务器接口，一般多次取平均值，获得最优的服务器使用，一般一段时间后比如一个小时重新遍历。 3. TCP+ProtoBuf策略代替HTTP+JSON，没试过，保留。 - 热修补方案，即H5和native页面通过后台来控制到底显示那个，需要注意页面的出入口，传递的参数，打点等等。完善还是需要一定积累的。 - AndroLua有机会可以研究下。 -根据Android的META-INFzhu&#39;ru快速打渠道包，直接上脚本了 import zipfileimport shutilimport osbase_dir = ‘/Users/Shared/‘apk_name = ‘ChannelDemo’apk_path = base_dir + apk_name + ‘.apk’empty_file = base_dir + ‘baojianqiang’f = open(empty_file, ‘w’)f.close()channel_file = base_dir + ‘channel.txt’f = open(channel_file)lines = f.readlines()f.close()output_dir = base_dir + ‘output’if not os.path.exists(output_dir)os.mkdir(output_dir)for line in linestarget_channel = line.strip()target_apk = outputdir + ‘/ChannelDemo‘ + target_channel + ‘.apk’shutil.copy(apk_path, target_apk)zipped = zipfile.ZipFile(target_apk, ‘a’, zipfile.ZIP_DEFLATED)empty_channelfile = ‘META-INF/channel‘ + target_channelzipped.write(empty_file, empty_channel_file)zipped.close() - 还有一个获得渠道号的方法 private String getChannel(Context context) { try { PackageManager pm = context.getPackageManager(); ApplicationInfo appInfo = pm.getApplicationInfo( context.getPackageName(), PackageManager.GET_META_DATA); return appInfo.metaData.getString(“channel”); } catch (PackageManager.NameNotFoundException ignored) { } return “”; }```","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《Android技能树探索》总览","date":"2017-08-07T16:00:00.000Z","path":"2017/08/08/《Android技能树探索》总览/","text":"这个系列也是属于构思了很久但是迟迟没法下手的，一方面也是因为自己心里面的那张技能图也不够清晰。深知在茫茫知识海洋中漫游拥有一张导航图是何等重要，前段时间发现了下面这张脑图，深以为然。于是想开始这个系列，在能力范围内把知识点都串一遍，看看又能收获多少了。 1.Android App 开发技术图谱 此图来自于https://github.com/mingjunli/AndroidDevResources/wiki/Android-App%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1侵权联系删除 https://github.com/mingjunli/AndroidDevResources/wiki/media/14695437899506/Android_App_Skill_Map.png 感谢作者能够画出这样比较详细的结构脑图，接下来可以稍微大概看一下。 2.庖丁初解牛2.1. 操作系统Windows/MacOSX/Linux 2.2. 编程语言JavaHTML/JS (Hybrid/Web App)C/C++ (NDK)SQL (DB)Kotlin 2.3. 开发工具2.3.1 IDEAndroid StudioEclipse 2.3.2 调试工具2.3.2.1 网络调试CharlesWiresharkFiddlertcpdumpPaw/Postman 2.3.2.2 内存分析monitorMAT 2.3.2.3 android toolsadbdraw9patchhierarchyvieweruiautomatorviewer 2.3.3 版本管理2.3.3.1 GitGit命令Github/GitLab 2.3.3.2 SVN2.3.4 CodeReviewGerritGithub pull request 2.3.5 Bug/任务管理RedmineJIRABugzillaTeambitionTower 2.3.6 编译工具Gradle 2.3.7 持续集成JenkinsTravis CI 2.3.8 应用分发蒲公英fir.im 2.4. App基础2.4.1 基本组件ActivityServiceContent ProviderBroadcast ReceiverIntent/ Intent FilterApp Manifest File 2.4.2 UILayoutsWidgetsResourcesAnimations设备适配 2.4.3 ConnectivityWifiMobile网络网络状态监听 2.4.4 MultiMediaAudio/VideoCamera/Gallery 2.4.5 GPS&amp;Location&amp;Map2.4.5.1 系统定位GPS定位Network定位 2.4.5.2第三方Map定位百度Map高德Map 2.5. App进阶2.5.1 Process&amp;Thread2.5.1.1 ProcessLinux进程App进程原理 2.5.1.2 AIDL实现方式原理 2.5.1.3 Handler/Looper/MQ/Thread2.5.1.4 Loader2.5.1.5 AsyncTask2.5.2 性能优化ANR布局层级性能优化 2.5.3 内存优化内存检测工具内存分析工具Bitmap优化内存泄漏查找及分析 2.5.4 网络优化2.5.4.1 API优化2.5.4.2 低网速下优化2.5.4.3 流量使用优化判断当前网络类型使用缓存 2.5.5 单元测试2.6. App高级2.6.1 相关原理熟悉2.6.1.1 Activity启动流程生命周期回调原理与View/Window的关系与Fragment的关系 2.6.1.2 View/WindowView/Window关系View渲染View事情分发处理流程 2.6.1.3 编译打包编译打包原理逆向工程分析热修复 2.6.2 Hybrid App2.6.2.1 与Native App的异同2.6.2.2 主流框架PhoneGapionicReact Native 2.6.3 架构能力2.6.3.1 架构MVCMVPMVVMFluxClean Architecture 2.6.3.2 APP框架分包分层 2.6.3.3 设计模式OOD原则常用设计模式运用 2.6.4 ART&amp;DalvikAOT compilationGCBytecode&amp;Dex 2.6.5 自动化测试monkey/monkey runnerUIAutomatorEspressoRobotium 2.7. 扩展学习2.7.1 响应式编程2.7.1.1 RXRxJavaRxAndroidRxBinding 2.7.1.2 Agera2.7.2 主流开源库2.7.2.1 快速开发Android AnnotationButterKnife 2.7.2.2 Views太多 2.7.2.3 Http模型RetrofitOkHttpVolley 2.7.2.4 图片处理GlideFrescoPicassoUIL 2.7.2.5 依赖注入Dagger2 2.7.2.6 数据库ORMLiteGreenDAORealmSugar 2.7.2.7 辅助LoggerLeakCanaryDbinspector 3.系列初步以上基本是根据某位大神画的脑图来的，后面想根据这个依据来一个系列，然后对号入座吧，每个point都可能是很长很长的技术之路，可能能力有限不过争取尽可能地详细，总是也是一个边分析边学习的过程了。这边文章既是一个提纲也是一个依据，以后可能还会陆续扩充和完善。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《易读》APP分析","date":"2017-07-18T16:00:00.000Z","path":"2017/07/19/《易读》APP分析/","text":"开篇：万事开头难，真的一点也不假。从意识到只有通过不断写作输出来整理笔记里的内容才有可能达到想达到的状态开始，也有好一段时间了。从基础开始吧，又觉得太散了无从下手，写架构吧，又怕能力不够变了纯吹牛逼。写作的目的本来也还是学习，在笔记本里收藏了N个开源优秀的项目了，也从来没有从头到尾好好看过，希望借这个机会能够从一而终一次吧，当然这也只是此时此刻单纯美好的愿望而已哈哈。 1.项目介绍1.1git上的大牛也是越来越多，分享出来的优秀项目也不占少数，这个项目也是其中之一。想要研究这个项目的原因一是现在Rxjava+Retrofit+dagger2+MVP的开发框架都主流得烂大街了有点，而自己目前接触到的公司项目却并没有用到这些，虽然零零星星做过不少demo，毕竟跟一个具有相对完整功能的APP的触感是不一样的。再就是这个项目开发的比较新，功能相对完善，代码结构也还算清晰简单。这里贴出项目的git地址，大家都可以去clone下来玩玩看，也可以去给作者点个star，哈哈https://github.com/laotan7237/EasyReader 1.2大家可以通过git项目主页的介绍加上自己下下来跑一下就能了解APP实现的主要功能了，下面是从功能的角度出发画了个脑图，请品尝：还算一目了然吧，所以这个APP的功能也还算简单的，就是一个新闻类的（好像开源的80%都是吧），也没有特别另类的功能，功能大概了解了，接下来就可以进入正题看代码了。 2.代码结构分析（1）2.1整个项目只有一个moudle，包结构如下传统分包模式，简单看一下 adpater：适配器，基本都是继承BaseQuickAdapter，所以看列表实现基本上都是采用的RecyclerView了，后面慢慢分析了。 app：Application和Constants配置 bean：不解释了 http：Retrofit相关的一些东西 injector：Dagger2相关的一些东西 presenter：MVP的P层，各种接口，和实现 rx：RxBus相关的东西 ui：activity和fragment utils：工具类 view：自定义view webview：里面也是一些工具类，和公共的webview页面和相关自定义配置到目前为止一级包结构也就这样了，还挺清晰吧。 2.2接下来就真的开始要愚公移山了，根据平时看代码的习惯开始好了，入口，一定是先从入口开始。App入口就是它了，里面代码很少，onCreate里初始化了一个全局变量外，有个Utils.init(this)，一个非常全的常用工具类，具体参考https://github.com/Blankj/AndroidUtilCode/blob/master/README-CN.md此外还有个getAppComponent方法，这个就要从漫长的Dagger2说起了。。。Dagger2要从头说起估计这篇文章就写不完了，然后刚刚又去看了下这篇博文https://dreamerhome.github.io/2016/07/07/dagger/看一遍可能还是会一头雾水，那就多在网上搜一下相关的东西吧，然后后面就是默认对Dagger2有个一知半解才能继续愉快地玩耍了。 2.3injector包的结构如下看过Dagger2应该就比较清晰一点了，scope里面定义的注解一般都是ActivityScope和FragmentScope，相当于是提供Activity和Fragment单例实例化的支持。再一个就是用qualifier定义的注解，他这里是定义了一些具体的网络请求，可以通过这个注解来区分具体返回哪个请求的Retrofit对象。module里面属于具体的提供者，提供什么就看需要什么了，这里面有各种adapter和各种http请求。然后我们知道component才是中间的粘合层，所以基本上module也会对应相应的component。如果还是一头雾水的，可以继续去看Dagger2的相关，或者记住一个信条，这样做了之后，需要的对象只要在这里弄好然后在使用的时候添加下注解就行了，不需要再new了。 2.4饶了一圈，又回来看Application了，刚刚其实就是这里还很多疑惑现在应该只有些许疑惑了吧，这里是返回的component，这个component拥有appModule和doubanHttpModule这两个module所提供的能力，具体是这个样子的所以就是App这个类提供了返回AppComponent的对象，这个对象可以提供获得App的context和或者一个mRetrofitDouBanUtils对象。 2.5mRetrofitDouBanUtils是什么呢，然后又会吧Rxjava和Retrofit带出来，是不是有点拔出萝卜带出泥的感觉，哦不，萝卜还早着呢。所以决定跳到第一个activity里面去。第一个是SplashActivity，简单的闪屏页，黄油刀butterknife应该都很熟悉了，配合AS的自动生成插件已经也算挺方便的了，解决了findViewById的重复劳动，虽然有不乏有人更加推崇Databinding+MVVM的方式，不过凡事总得慢慢来，好的东西可是可以去了解学习的，好了不扯远了，butterknife需要注意的地方是一般持有一个Unbinder，在onDestroy的时候要反绑定，也算是一个性能上的注意点了。其他的没啥好说的，两秒后跳到MainActivity。 2.6写到现在终于能看到主页面了，然后还是轮不到MainActivity，还有他的基类BaseActivity呢。BaseActivity里面里大致做了三件事情 管理所有的acticity页面，声明一个static的List，activity在onCreate时把自己放到list里面去，在onDestroy的时候从list里面移除，并且提供一个killAll的方法来关闭所有acticity。 实现类似IOS的滑动关闭页面，这个属于锦上添花的东西了，有兴趣的可以自己了解下。 实现LifeSubscription，添加rx的监听，然后在页面销毁时释放防止泄露。Rx的每个操作都可以作为一个Subscription添加到CompositeSubscription里面去，所以合理的就是在基类统一管理，在销毁页面的时候切断操作，防止内存泄漏。除了以上三点外当然还应该做一些生命周期的常规封装，这个都是仁者见仁又大同小异，就不单独拧出来说了。 2.7终于可以看看MainActivity，多少不容易啊，先看UI，UI能让人快乐。看过APP效果的都知道用的DrawerLayout，用法当然不属于这里的讨论范围，不过还是贴个连接好了http://blog.csdn.net/wangyangyang_n/article/details/50586921然后布局就不用再细说啦，虽然侧滑里面的跟layout是用的NestedScrollView，不过在那个界面没啥卵用，所有关于Material Design的一些后面还有机会讲的。MainActivity里面就是初始化了UI，结构就是DrawerLayout+ViewPager+Fragment这样子，然后值得一提的还有个MaterialSearchView开源控件，就是搜索框，也是属于特定需求的开源控件了，有兴趣了解下就行。ToastUtils和SPUtils属于基本工具类了，怎么实现的姿势都行，还记得在application里面初始化的那个工具类吗，拿过来用就行。以上都是架子，内容还没有，之前从产品功能上看不是分为三个大类吗，其实就是三个fragment啦。 2.8从那张脑图上可以看出HomeFragment是最复杂的，所以先分析另外两个吧。首先看AndroidFragment，不过说了这么久怎么连点MVP的影子都还没看到，恩，这才是刚刚开始。先看父类BaseFragment，首先是持有泛型BasePresenter，LifeSubscription接口和之前分析的BaseActivity一样的，不多说了，另外一个接口Stateful又要扯到LoadingPage了。LoadingPage是个不错的东西，在每个APP里面也都是必须的，封装了加载时，加载成功失败，失败后刷新等的页面状态，只需要传一个state，其他逻辑跟着回调来就行了，虽然也封装过类似的东西，不过这种思路还是挺值得学习的。里面还有个点就是Fragment的懒加载，基本上也是出行必备的东西了，网站随便找一篇博客可以看看http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1021/1813.html此外还有几个虚函数共子类重写，状态保持和mLoadingPage一致。这个类最开始用@Inject标签标注的也是给子类用的，相当于在这里new了一个该对象，至于为什么还是可以去看看Dagger2的东西哈。 2.9接下来可以看AndroidFragment里面的东东了，这里决定先来张图以至于不要那么晕是不是有点MVP的感觉了，Fragment作为View层持有了Presenter层的实例并继承View层的接口，那么Presenter拿到了数据就会回调到接口中，实现业务与界面的分离。SwipeRefreshLayout是一个谷歌自己的下拉刷新组件，没什么特别的要求用这个应该是挺合适的，里面是标准的RecyclerView，相信现在出去说我们项目列表还是ListView实现估计要遭人鄙视了吧。在BaseFragment的onCreateView方法里面会调用loadBaseData方法，然后会调loadData方法，在子类里面实现这个方法，在AndroidFragment中为 mPresenter.fetchGankIoData(page,PRE_PAGE); 就是在网络加载数据了，还是进去看看吧。 2.10BasePresenter是持有一个BaseView的接口的，然后里面的invoke方法传入Observable和Subscriber的callback。然后自然就关系HttpUtils的invoke方法了，里面更新了状态，判断了网络情况，然后就是RxJava的观察者绑定了还会把subscription放到一个统一的池子里管理。然后跳回来看看GankIoAndroidPresenterImpl的fetchGankIoData方法 @Override public void fetchGankIoData(int page, int pre_page) { invoke(mRetrofitGankIoUtils.fetchGankIoData(&quot;Android&quot;,page,pre_page),new Callback&lt;GankIoDataBean&gt;(){ @Override public void onResponse(GankIoDataBean data) { List&lt;GankIoDataBean.ResultBean&gt; results = data.getResults(); checkState(results); mView.refreshView(results); } }); } 所以第一个参数就是Retrofit返回的Observable了 /** * 分类数据: http://gank.io/api/data/数据类型/请求个数/第几页 * 数据类型： 福利 | Android | iOS | 休息视频 | 拓展资源 | 前端 | all * 请求个数： 数字，大于0 * 第几页：数字，大于0 * eg: http://gank.io/api/data/Android/10/1 */ @GET(&quot;data/{type}/{pre_page}/{page}&quot;) Observable&lt;GankIoDataBean&gt; getGankIoData(@Path(&quot;type&quot;) String id, @Path(&quot;page&quot;) int page, @Path(&quot;pre_page&quot;) int pre_page); 不得不说作者的注释真是写得够详细，点个赞。中间的RetrofitGankIoUtils持有一个GankIoService作为HttpUtils的子类，这样就可以成为很好的分类封装了。回调的Callback拿到数据之后检查状态看看应该显示怎样的页面，然后把数据交回给view完成显示。到这里一个基于MVP的网络请求流程就走通了，感觉很爽有木有。还有个比较值得说的是AndroidFragment里面的adapter，我们已经知道这个页面使用的是RecycleView，然后有一个比较牛逼的组件BaseRecyclerViewAdapterHelper，据说非常灵活还精简代码还完善了普通RecycleView的一些短板，比较点击事件，header和footer之类的，可以参考下面这个博文http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0417/4154.html可以结合本项目参考下使用方法，希望能在下个自己的项目中用进去。最后需要注意的一个地方是initInject这个重载方法，我们在每个具体子页面里面通过这样注入了网络框架依赖和适配器依赖，就可以在这个页面里随便用啦。 2.11看界面也能看出来，WeChatFragment和AndroidFragment里面的东西也是半斤八两啦。然后就是根据具体业务使用的是WeChatPresenterImpl和WeChatPresenter.View，这个逻辑就不重复说了，有点区别的就是还记得MainActivity里面的MaterialSearchView吗，里面有这么一段代码 searchView.setOnQueryTextListener(new MaterialSearchView.OnQueryTextListener() { @Override public boolean onQueryTextSubmit(String query) { vpContent.setCurrentItem(2); RxBus.getDefault().post(AppConstants.WECHA_SEARCH, query); return false; } @Override public boolean onQueryTextChange(String newText) { return true; } }); 所以这里就是RxBus的封装和使用了，看这篇好了http://www.loongwind.com/archives/264.html看完其他感觉也不用怎么说了，跟eventBus差不多的姿势就行了，所有我们可以发现在这里发出了要查询的关键字，然后通过AppConstants.WECHA_SEARCH这个常量在WeChatFragment里面接收到这个关键字然后 mPresenter.fetchWXHotSearch(20, 1, s); 当然还不要忘了CompositeSubscription来管理，保持优雅的姿势。至于Presenter都是差不多的流程，直接看代码会清楚很多的。 2.12到此为止以为这两页面功能都已经分析完了，结果发现尼玛详情页完全没有说啊，幸好是个webview哈哈。这一小节来扫扫尾。不得不说使用了BaseQuickAdapter代码真心精简了好多，viewholder也不需要自己写了的样子。WeChatAdapter使用的是一个cardview，然后详情页就是把title和url塞到WebViewActivity里面去。GankIoAndroidAdapter里面的逻辑基本也都是一样的，值得一提的是把Glide根据不同的业务需求封装成了GlideUtils，可以参考一下，Glide对GIF也比较友好哟呵呵。然后说说WebViewActivity，也算是居家旅行必备的一个累了，作者的介绍说满足拨打电话、发送短信、发送邮件、上传图片、播放视频等需求了，应该还不错吧，虽然也可以自己写，贴个地址http://www.jianshu.com/p/163d39e562f0能拿来主义的时候千万不要手软。WebViewActivity在toolbar里面可以分享，复制和在浏览器中打开网页也比较好用，分享就是使用了安卓原生的Intent.ACTION_SEND就行分享，看上去效果也还不错，是时候干掉sharkSDK了呵呵，可以参考下面博文http://blog.csdn.net/wuzhiguo1314/article/details/52950764 3.代码结构分析（2）3.1终于只剩最后也是最大的这一块了，进度比我想象的要快很多啊，稳住我们能赢。先来看看HomeFragment吧，这也页面使用了TabLayout+ViewPager的布局，就注定它也只是个容器，也没什么MVP，所以就直接继承了Fragment。TabLayout只需要两行代码就能实现一个指示器，还是非常推荐用的。 mFragments.add(new ZhiHuHomeFragment()); mFragments.add(new TopNewsFragment()); mFragments.add(new DouBanMovieTopFragment()); mFragments.add(new DouBanMovieLatestFragment()); 然后里面又是四个Fragment，想想也知道这些大多结构逻辑都会是一样的，所以先看第一个吧。额···其实分析了之前两个列表Fragment后感觉也没啥好说的了，找找亮点，找找亮点。轮播图是个好东西啊，最开始来自web页面，现在在android上也是直接拿来https://github.com/youth5201314/banner/里面说的应该很详细了，虽然也没用过，不过需要的时候照着画瓢不至于画不出来吧。这个轮播图和下面那个分类（项目中没啥卵用）是统一作为header添加到RecyclerView里面去的。等等，为什么RecyclerView可以添加header??还记得BaseQuickAdapter这个牛逼玩意儿吗，让能够像listview一样添加header和footer，真是鱼和熊掌都要啊。这个页面的数据请求与加载也有点意思，一切要从 @Override protected void loadData() { mPresenter.fetchData(); } 说起。我们点进去看发现是这样的，首先执行了fetchDailyData方法请求了日报内容，成功后先是设置了title和title的type为0，再把请求到的数据填入了一个大的bean里面就是homeListBean，设置type为1，然后再执行fetchHotList，设置title和title的type为0，再把请求到的数据填入homeListBean，设置type为2，如此循环到最后的fetchSectionList，最后一个接口回来了再去回调view层。然后这个type就是adpter的type了，BaseQuickAdapter有个子类BaseMultiItemQuickAdapter，可以使用addItemType来定义不同的列表项type，刚开始看到这个页面还以为是多个列表，没想到一个recycleView就能搞定，ZhiHuAdapter里面也已经做了很好的例子，然后把点击事件回调到外面，大概就是这样子的，其实这个adapter的排版方式有点臃肿，不过一想全部又嵌套一层list的话肯定有是更多坑了，不吐槽。 3.2从回调回来的结构看，日报和热门是走的同一个回调的，然后主题和专栏是分别不同的，所以是三个回调，但是前两者都是跳转到ZhiHuDetailActivity，后两者都是跳转到ZhihuThemeActivity。值得一说的是跳转中使用了ActivityOptionsCompat来控制跳转动画，这个在Material Design是非常有用的，看上去就酷炫叼有木有，参考下面这篇http://blog.csdn.net/qibin0506/article/details/48129139/ 3.3这次没忘，接着看详情页吧。先应该是ZhiHuDetailActivity，然后就可以聊聊Material Design了。还是乐观了，还以为对activity的封装只有BaseActivity那么简单，其实并不是，都还没有MVP呢。还没有封装LoadingPage，Material Design也得封装一下吧。所以结构应该是这个样子的当然其实LoadingBaseActivity有6个子类，总是都是这种尿性了。其实LoadingBaseActivity和之前分析的BaseFragment有些神似，个人感觉这样的封装还是很不错的，的确让子类省去了一些重复劳动，用接口重载的方式也比较灵活。ZhihuDetailBaseActivity其实代码很少，Material Design可以看看这篇http://blog.csdn.net/qq_31340657/article/details/51918773感觉这种也没什么好分析，自己写过玩过踩过坑才算真正了解了。再回到ZhiHuDetailActivity这个类，中间有个webview，需要在initview的时候各种初始化配置，下面那个点赞和评论的layout不是behavior，是一个简单的属性动画，然后在loadData的地方使用mPresenter请求了页面内容（也就是webview的填充内容）和评论点赞内容。从ZhiHuDetailPresenterImpl里面跟进过去可以知道通过showExtraInfo和refreshView回调。点击评论可以到评论详情里面去，当然是携带了这个页面的一堆参数过去的。 3.4阿西吧，ZhiHuCommentActivity又是一个Toolbar+TabLayout+ViewPager的布局，刚刚传过来参数只是简单的显示条数，肯定还是有具体的Fragment的。对，就是ZhiHuCommentFragment，两个都是。其他的MVP结构就不再描述了，所持有的Presenter有fetchShortCommentInfo和fetchLongCommentInfo两个方法去请求具体的评论，再注入到ZhiHuCommentAdapter里面去。CircleImageView用的可以自取，参考https://github.com/hdodenhof/CircleImageView剩下里面的逻辑结合APP对应的页面看看就好，那个收起和展开点了似乎没啥反应啊，不过那都不重要。这个就先到这里了。 3.5接下来是不是应该看ZhihuThemeActivity，前面分析之后感觉这个也没啥好说，唯一有点不一样的是这个是个公共页面。initView和loadData都是走分支的，然后回调也不走一样的，填充到不同的adpter，刷新数据。然后每个item点击带上id继续走到startZhiHuDetailActivity里面，这样就通了。顺便说一句Glide+recycleview真是好组合啊，现在面试去问别人怎么样优化listview滑动卡顿感觉自己都不好意了。 3.6接下来是一个有意思的东西，ZhiHuHomeFragment里面的几个模块，日报，热门，专栏，主题，有个按钮跳到一个页面，可以动态调整这几个栏目的顺序，看上去还挺好玩儿的吧。这个页面是HomeAdjustmentListActivity，其实在recycleview时代实现这种效果已经不难了，看看这个吧https://github.com/CymChad/BaseRecyclerViewAdapterHelper/wiki/%E6%B7%BB%E5%8A%A0%E6%8B%96%E6%8B%BD%E3%80%81%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4然后配合sp就可以很轻松愉快地实现这个功能了。 3.7头条新闻这个TopNewsFragment刷不出来数据，就先不管了，反正都差不多的啦。DouBanMovieTopFragment也是RecyclerView没跑了，adapter太强大了，连LoadMoreView都可以传个自定义xml就行，然后跳转到MovieTopDetailActivity，跳转的动画其实挺好的，不过之前也已经分析过了，特定的UI结构也没啥好说的。DouBanMovieLatestFragment也是一样的，他们之间布局不同是因为一个使用了StaggeredGridLayoutManager一个使用了LinearLayoutManager。 4.总结这个APP到目前为止就基本上告一段落，没想到原本计划1个月左右结果就搞了三天，总体来说这个APP还是有不少亮点和值得学习的地方，再次感谢作者，这也是第一个完整分析得差不多的APP，还是感觉收获不少，还是那句话，输出是消化的重要途径，所以，后面还要加油。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《Android技能树探索》基础篇---Broadcast","date":"2017-06-06T16:00:00.000Z","path":"2017/06/07/《Android技能树探索》基础篇---Broadcast/","text":"广播一直以来都是使用频率仅次于Activity的四大组件，使用也非常简单。虽然现在很多项目都慢慢使用EventBus来替代广播，但必要的了解了对各种坑的预防依然还是必不可少的，好了废话就到这里。 1.广播的类型？ Normal broadcasts无序广播（sendBroadcast），会异步的发送给所有的Receiver，接收到广播的顺序是不确定的，有可能是同时。 Ordered broadcasts有序广播（sendOrderBroadcast），广播会先发送给优先级高(android:priority -1000到1000)的Receiver，而且这个Receiver有权决定是继续发送到下一个Receiver或者是直接终止广播。其他衍生广播： sendStickyBroadcast：Sticky简单说就是，在发送广播时Reciever还没有被注册，但它注册后还是可以收到在它之前发送的那条广播。 LocalBroadcastManager.getInstance(this). sendBroadcast：应用内广播，没有特殊需求推荐使用，方便高效安全。 2.广播的注册方式和注意事项？动态注册和静态注册。 静态订阅广播又叫：常驻型广播，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，他的注册方式就是在你的应用程序中的AndroidManifast.xml进行订阅的。 动态订阅广播又叫：非常驻型广播，当应用程序结束了，广播自然就没有了，比如你在activity中的onCreate或者onResume中订阅广播，同时你必须在onDestory或者onPause中取消广播订阅。不然会报异常，这样你的广播接收器就一个非常驻型的了。 这里面还有一个细节那就是这两种订阅方式，在发送广播的时候需要注意的是：动态注册的时候使用的是隐式intent方式的，所以在发送广播的时候需要使用隐式Intent去发送，不然是广播接收者是接收不到广播的，这一点要注意。但是静态订阅的时候，因为在AndroidMainfest.xml中订阅的，所以在发送广播的时候使用显示Intent和隐式Intent都可以(当然这个只针对于我们自己定义的广播接收者)，所以以防万一，我们一般都采用隐式Intent去发送广播。注：内部广播接收器一定要是static不然无效。 3.BroadcastReceiver的生命周期？Receiver也是有生命周期的，而且很短，当它的onReceive方法执行完成后，它的生命周期就结束了。这时BroadcastReceiver已经不处于active状态，被系统杀掉的概率极高，也就是说如果你在onReceive去开线程进行异步操作或者打开Dialog都有可能在没达到你要的结果时进程就被系统杀掉。因为这个进程可能只有这个Receiver这个组件在运行，当Receiver也执行完后就是一个empty进程，是最容易被系统杀掉的。替代的方案是用Notificaiton或者Service（这种情况当然不能用bindService）。换句话说，当BroadcastReceiver在10秒内没有执行完毕，Android会认为该程序无响应。如果需要完成一项比较耗时的工作，应该通过发送Intent给Service，由Service来完成。而不是使用子线程的方法来解决，因为BroadcastReceiver的生命周期很短（在onReceive()执行后BroadcastReceiver 的实例就会被销毁），子线程可能还没有结束BroadcastReceiver就先结束了。如果BroadcastReceiver结束了，它的宿主进程还在运行，那么子线程还会继续执行。但宿主进程此时很容易在系统需要内存时被优先杀死，因为它属于空进程（没有任何活动组件的进程）。 4.使用广播来更新界面是否合适？综上，低频不耗时的更新没啥问题，如果是高频或者耗时的话就应该考虑其他方法了。发广播虽然方便但一定要统一管理，滥发广播会让项目变得相当不可维护，进程间通信最好使用aidl等更加安全可靠。 5.安卓中跨进程通信的方式？ 隐式Intent访问其他应用程序的Activity。 Content Provider 广播（Broadcast） AIDL 6.参考博文 http://blog.csdn.net/jiangwei0910410003/article/details/19150705http://blog.chinaunix.net/uid-25314474-id-2846624.htmlhttp://www.jianshu.com/p/df7af437e766","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"Android下载模块探究","date":"2017-05-09T16:00:00.000Z","path":"2017/05/10/Android下载模块探究/","text":"开篇：APP中的下载模块，其实也算一个网络访问的模块，但又和一般的后台接口之类网络请求不太一样。而且到目前为止，类似okhttp,volley之类的接口请求框架非常丰富，下载模块总会让开发者去花更多心思去完善流程。现在没有网络请求的APP已经少得可怜了，相比之下下载显得不是那么必须，但是在一个相对成熟的APP中，不管是数据库，还是下载都是必不可缺的，说多了都是废话，还是进入正题好了。PS：本文依旧以实现功能为导向，不对具体原理做深入解释，相关请自己百度谷歌一下。 1.从上至下从原理开始分析总觉得很容易让人迷惑，不妨从应用的层面上来分解这个问题（后面遇到坑再填好了），先来看看Demo的界面：界面不要太简单有木有。 功能是这样的，这个APP一启动起来在onCreate里面就会下载一个文件，当然是在后台log打进度日志啦，点击暂停就暂停下载，点击继续续传下载，当然如果完全退出APP甚至是重启手机也是可以断点续传的。点击开始下载2并不会影响上一个下载。好了可以开始看代码了： String appUrl = &quot;http://music.baidu.com/cms/BaiduMusic-pcwebdownload.apk&quot;; String downloadPath = Environment.getExternalStorageDirectory() + &quot;/BaiduMusic-pcwebdownload.apk&quot;; upgradeTaskId = DownLoadManager.getInstance(getApplicationContext()).addTask(null, appUrl, downloadPath, true, this); Log.d(&quot;kkkkkkkk&quot;, &quot;initData upgradeTaskId --&gt; &quot; + upgradeTaskId); 以上代码是在onCreate里面做的，也就是说页面启动的时候就添加了一个下载任务，在这里的逻辑也就是开始下载了。看到了那个醒目的DownLoadManager了吗，里面有很多东西，不妨来慢慢分解它： private DownLoadManager(Context context) { mContext = context; mPool = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIUM_POOL_SIZE, KEEP_LIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(QUEUE_SIZE)); } public static DownLoadManager getInstance(Context context) { if (mInstance == null) { synchronized (DownLoadManager.class) { if (mInstance == null) { mInstance = new DownLoadManager(context); } } } return mInstance; } 作为一个manager，单例是基本素养，就不多说了，来看构造函数里面的几个东东。context主要用到了3个地方，1是创建数据库，2是https获得证书，3是注册广播。什么？为啥有数据库？没有数据库怎么牛逼地断点续传呢·····先剧透到这里，接着看mPool，这个是一个线程池，每一个下载相当于从这个线程池里捞出线程来执行下载任务，里面这几个参数private static final int CORE_POOL_SIZE = 5; private static final int MAXIUM_POOL_SIZE = 10; private static final int KEEP_LIVE_TIME = 30; private static final int QUEUE_SIZE = 2000;先看看就行了。首先来看看addTask的实现 public String addTask(String uid, String url, String path, boolean isSupportBreakpoint, DownLoadCallBack callBack) { Log.d(TAG, &quot;url=&quot; + url); Log.d(TAG, &quot;path=&quot; + path); String taskId = getTaskId(uid, url, path); Log.d(TAG, &quot;taskId=&quot; + taskId); DownLoader downLoader = findTask(uid, taskId, true); if (downLoader == null) { String fileName = path.substring(path.lastIndexOf(&quot;/&quot;) + 1); String filePath = path.substring(0, path.lastIndexOf(&quot;/&quot;)); Log.d(TAG, &quot;fileName=&quot; + fileName); Log.d(TAG, &quot;filePath=&quot; + filePath); DownLoadBean info = new DownLoadBean(); if (TextUtils.isEmpty(uid)) { uid = &quot;12345&quot;;// UserManager.getCurUserId(); } info.setUserID(uid); info.setTaskID(taskId); info.setFilePath(filePath); info.setFileName(fileName); info.setIsSupportBreakpoint(isSupportBreakpoint); info.setUrl(url); downLoader = new DownLoader(mContext, info, mPool, true); mDownLoaderList.put(taskId, downLoader); } else { if (!mDownLoaderList.containsKey(taskId)) { mDownLoaderList.put(taskId, downLoader); } } registReceiver(); downLoader.setDownLoadCallBack(callBack); if (!downLoader.isDownLoading()) { downLoader.start(); } return taskId; } 从基本的流程来捋一遍吧，首先是把uid, url, path这三个参数通过getTaskId方法生成一个taskId,其实就是拼起来md5了一下： private String getTaskId(String uid, String url, String path) { return StringUtil.md5(uid + url + path); } 加密算法如下，不解释啦： public static String md5(String s) { char hexDigits[] = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; }; try { byte[] strTemp = s.getBytes(); // 使用MD5创建MessageDigest对象 MessageDigest mdTemp = MessageDigest.getInstance(&quot;MD5&quot;); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) { byte b = md[i]; // 将每个数(int)b进行双字节加密 str[k++] = hexDigits[b &gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[b &amp; 0xf]; } return new String(str); } catch (Exception e) { return null; } } 然后回去通过findTask去找数据库中是否有对应DownLoader，如果有的话直接把它放到mDownLoaderList中然后调用DownLoader的start方法，如果没有我们继续看。这里有个实体类DownLoadBean来存放下载的相关信息，有必要来先看看里面的字段： private String userID; private String taskID; private String url; private String filePath; private String fileName; private long fileSize; private long downloadSize; private boolean isSupportBreakpoint; 从名字上基本可以望文生义了，不需要太多解释吧。刚刚说到如果findTask的DownLoader是空的，证明是第一次下载这个任务，那么需要重新构造下载相关信息。从代码上可以看出来除了fileSize和downloadSize没法构造其他的都可以直接塞进去了，最后通过downLoader = new DownLoader(mContext, info, mPool, true);来生成一个新的DownLoader，然后后面就跟从数据库中找到一样操作了。无非就是加入到一个list中去方便管理，和开启下载任务。当然还有一个registReceiver方法，先看看吧，顺便把反注册也贴上来了： private void registReceiver() { if (mNetStateBroadCastReceiver == null) { mNetStateBroadCastReceiver = new NetStateReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); mContext.registerReceiver(mNetStateBroadCastReceiver, filter); } } private void unRegistReceiver() { if (mDownLoaderList.isEmpty() &amp;&amp; mNetStateBroadCastReceiver != null) { mContext.unregisterReceiver(mNetStateBroadCastReceiver); mNetStateBroadCastReceiver = null; } } 注册了一个监听网络状态变化的广播监听器： public class NetStateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = manager.getActiveNetworkInfo(); if (networkInfo != null) { if (networkInfo.isAvailable()) { if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) { DownLoadManager.getInstance(context).startAllTask(); } else { DownLoadManager.getInstance(context).stopAllTask(); } } else { DownLoadManager.getInstance(context).stopAllTask(); } } else { DownLoadManager.getInstance(context).stopAllTask(); } } } 大概意思就是在wifi环境下所有任务自动下载，非wifi环境和断网下自动停止，真是好人性化好贴心好不做作，跟外面那些妖艳贱货完全不一样，当然这个根据自己的业务自己去处理这种逻辑才是王道呢科科。广播监听器里面方法有startAllTask和stopAllTask，看看里面都干了些什么： public void startAllTask() { Set&lt;Entry&lt;String, DownLoader&gt;&gt; set = mDownLoaderList.entrySet(); Iterator&lt;Entry&lt;String, DownLoader&gt;&gt; iterator = set.iterator(); while (iterator.hasNext()) { Entry&lt;String, DownLoader&gt; entry = iterator.next(); DownLoader downLoader = entry.getValue(); if (downLoader != null &amp;&amp; !downLoader.isDownLoading()) { downLoader.start(); } } } public void stopAllTask() { Set&lt;Entry&lt;String, DownLoader&gt;&gt; set = mDownLoaderList.entrySet(); Iterator&lt;Entry&lt;String, DownLoader&gt;&gt; iterator = set.iterator(); while (iterator.hasNext()) { Entry&lt;String, DownLoader&gt; entry = iterator.next(); DownLoader downLoader = entry.getValue(); if (downLoader != null &amp;&amp; downLoader.isDownLoading()) { downLoader.stop(); } } unRegistReceiver(); } 知道刚刚为什么要把DownLoader都塞到mDownLoaderList里面去了吧，好了马上要进入下一步了，分析到现在很明显了，所有的下载核心都封装在一个DownLoader类中，每一个下载都对应一个DownLoader，它们被装在一个mDownLoaderList的容器里方便管理。 2.DownLoader初探刚刚我们看到，新建一个新的下载任务会用downLoader = new DownLoader(mContext, info, mPool, true);来创建一个新的DownLoader，那么从构造函数开始吧： public DownLoader(Context context, DownLoadBean sqlFileInfo, ThreadPoolExecutor pool, boolean isNewTask) { mContext = context; mSQLDownLoadInfo = sqlFileInfo; mPool = pool; mIsSupportBreakpoint = sqlFileInfo.isSupportBreakpoint(); mUrl = mSQLDownLoadInfo.getUrl(); mFileSize = mSQLDownLoadInfo.getFileSize(); mDownLoadSize = mSQLDownLoadInfo.getDownloadSize(); mFilePath = mSQLDownLoadInfo.getFilePath(); mFileName = mSQLDownLoadInfo.getFileName(); mHelper = DownloadTaskDBHelper.getInstance(context); if (isNewTask) { mHelper.save(sqlFileInfo); } } 用参数初始化了一堆变量，反正就放那里没错啦，然后创建了一个DownloadTaskDBHelper实例，我们先把mHelper当黑盒好了，后面再专门看看这个数据库是怎么设计与实现的。既然构造函数没有什么，那么看看start方法吧： public void start() { if (mDownLoadTask == null) { mDownLoadTask = new DownLoadTask(); } mPool.execute(mDownLoadTask); ondownload = true; mHandler.sendEmptyMessage(TASK_START); } 先看最后一句话，是一个handler的消息，其实用来回调的： private Handler mHandler = new Handler(Looper.getMainLooper()) { @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (mDownLoadCallBack != null) { if (msg.what == TASK_START) { // 开始下载 mDownLoadCallBack.onStart(getTaskID()); } else if (msg.what == TASK_STOP) { // 停止下载 mDownLoadCallBack.onStop(mFileSize, mDownLoadSize, getTaskID()); if (mDownLoadSize == 0) { mDownLoadCallBack = null; } } else if (msg.what == TASK_PROGESS) { // 改变进程 mDownLoadCallBack.onLoading(mFileSize, mDownLoadSize); } else if (msg.what == TASK_ERROR) { // 下载出错 String error_msg = msg.getData().getString(ERROR_KEY); mDownLoadCallBack.onFailure(error_msg); } else if (msg.what == TASK_SUCCESS) { // 下载完成 mDownLoadCallBack.onSuccess(mFilePath + File.separator + mFileName, getTaskID()); mDownLoadCallBack = null; } } } }; 再来看看接口的定义： public interface DownLoadCallBack { void onStart(String taskID); void onLoading(long total, long current); void onSuccess(String path, String taskID); void onFailure(String msg); void onStop(long total, long current, String taskID); } 这些回调主要是让使用着知道下载状态，虽然必须但没啥好说的，现在把代码贴出来主要是后面看到相关代码懵逼。好了我们现在回到start方法，新建了一个DownLoadTask并且使用线程池来执行了它，DownLoadTask是一个runnable，也就是下载的具体实现了，来来来接着看。DownLoadTask里面的run方法就只有一个download方法，看来这是下载的全部东东了，先贴出来分析下： private void downLoad() { if (mDownLoadSize == mFileSize &amp;&amp; mFileSize &gt; 0) {// 如果下好的文件大小与文件本身大小一样，则默认已经下载完成，不再下载 ondownload = false; mHandler.sendEmptyMessage(TASK_PROGESS); mDownLoadTask = null; return; } ConnectionWrapperManager manager = null; InputStream inputStream = null; try { manager = new ConnectionWrapperManager(mContext, mUrl); manager.setRequestMethod(DownLoadManager.RequsteMethod.GET); manager.setConnectTimeout(CONNECT_TIME_OUT); manager.setReadTimeout(READ_TIME_OUT); if (mDownLoadSize &lt; 1) {// 第一次下载，初始化 openConnention(manager); } else { if (new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;).exists()) { mLocalFile = new RandomAccessFile(mFilePath + File.separator + mFileName + &quot;.tmp&quot;, &quot;rwd&quot;); mLocalFile.seek(mDownLoadSize); manager.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + mDownLoadSize + &quot;-&quot;); } else { mFileSize = 0; mDownLoadSize = 0; openConnention(manager); saveDownloadInfo(); } } inputStream = manager.getInputStream(); byte[] buffer = new byte[1024 * 4]; int length = -1; if (inputStream != null) { while ((length = inputStream.read(buffer)) != -1 &amp;&amp; isdownloading) { mLocalFile.write(buffer, 0, length); mDownLoadSize += length; mSafeDownLoadSize = mDownLoadSize; mHandler.sendEmptyMessage(TASK_PROGESS); } } // 下载完了 if (mDownLoadSize == mFileSize) { boolean renameResult = renameFile(); if (renameResult) { mHandler.sendEmptyMessage(TASK_SUCCESS); // 转移文件成功 } else { new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;).delete(); Message msg = Message.obtain(); msg.what = TASK_ERROR; Bundle bundle = new Bundle(); bundle.putString(ERROR_KEY, &quot;转移文件失败&quot;); msg.setData(bundle); mHandler.sendEmptyMessage(TASK_ERROR);// 转移文件失败 } // 清除数据库任务 mHelper.deleteDownLoadInfo(mSQLDownLoadInfo.getUserID(), getTaskID()); mDownLoadTask = null; mDownLoadCallBack = null; ondownload = false; mDownLoadSize = 0; mSafeDownLoadSize = 0; } } catch (Exception e) { e.printStackTrace(); if (isdownloading) { if (mIsSupportBreakpoint) { try { if (mLocalFile != null) { long length = mLocalFile.length(); if (length &gt; 0) { saveDownloadInfo(); } } } catch (IOException e1) { e1.printStackTrace(); } } ondownload = false; mPool.remove(mDownLoadTask); mDownLoadTask.stopDownLoad(); mDownLoadTask = null; Message msg = Message.obtain(); msg.what = TASK_ERROR; Bundle bundle = new Bundle(); bundle.putString(ERROR_KEY, e.getMessage()); msg.setData(bundle); mHandler.sendMessage(msg); } } finally { if (manager != null) { manager.disconnect(); } if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if (mLocalFile != null) { try { mLocalFile.close(); } catch (IOException e) { e.printStackTrace(); } } } } 代码看上去也没那么多是不是，其实也没那么简单，带着一步一坑的想法慢慢看吧。刚开始的一个判断没什么，然后声明了ConnectionWrapperManager，这又是个什么鬼，看看后面的一些逻辑，发现原来所有下载操作都是它来完成，真是层层代理呢，关于ConnectionWrapperManager还是专门拧一个小节会比较有层次感吧。 3.ConnectionWrapperManager真面目首先看看包结构可能够容易只管了解一点：UrlConnectionWrapper是一个接口，封装了HttpsURLConnection和HttpURLConnection的各个方法： public interface UrlConnectionWrapper { void setRequestMethod(DownLoadManager.RequsteMethod method); int getResponseCode(); void setDoOutPut(boolean newValue); InputStream getInputStream(); void setConnectTimeout(int timeout); void setReadTimeout(int timeout); void setRequestProperty(String range, String s); void disconnect(); long getFileSize(); } 所以这个其实就是一个适配器模式，ConnectionWrapperManager是一个适配器，它会根据URL来选择使用HttpUrlConnectionWrapper还是HttpsUrlConnectionWrapper里的相应方法，从而达到支持http和https，而HttpUrlConnectionWrapper和HttpsUrlConnectionWrapper里面当然就是调用HttpURLConnection和HttpsURLConnection的方法啦，这里只贴出HttpUrlConnectionWrapper的代码，HttpsUrlConnectionWrapper里面有一些ssl和证书等的相关处理，有兴趣的自己百度吧，不然感觉真心是越扯越远有点收不回来了。 public class HttpUrlConnectionWrapper implements UrlConnectionWrapper{ private HttpURLConnection mHttpURLConnection; public HttpUrlConnectionWrapper(HttpURLConnection connection) { mHttpURLConnection = connection; } @Override public void setRequestMethod(DownLoadManager.RequsteMethod method) { try { if(method == DownLoadManager.RequsteMethod.GET){ mHttpURLConnection.setRequestMethod(&quot;GET&quot;); } else { mHttpURLConnection.setRequestMethod(&quot;POST&quot;); } } catch (ProtocolException e) { e.printStackTrace(); } } @Override public int getResponseCode() { try { return mHttpURLConnection.getResponseCode(); } catch (IOException e) { e.printStackTrace(); } return -1; } @Override public void setDoOutPut(boolean newValue) { mHttpURLConnection.setDoOutput(newValue); } @Override public InputStream getInputStream() { try { return mHttpURLConnection.getInputStream(); } catch (IOException e) { e.printStackTrace(); } return null; } @Override public void setConnectTimeout(int timeout) { mHttpURLConnection.setConnectTimeout(timeout); } @Override public void setReadTimeout(int timeout) { mHttpURLConnection.setReadTimeout(timeout); } @Override public void setRequestProperty(String range, String s) { mHttpURLConnection.setRequestProperty(range, s); } @Override public void disconnect() { mHttpURLConnection.disconnect(); } @Override public long getFileSize() { return mHttpURLConnection.getContentLength(); } } 简单清楚明白吧，再来看看封装成ConnectionWrapperManager的代码： public class ConnectionWrapperManager implements UrlConnectionWrapper{ private UrlConnectionWrapper mWrapper; public ConnectionWrapperManager(Context context, String murl) { try { URL url = new URL(murl); if (murl.startsWith(&quot;https&quot;)){ HttpsURLConnection conn = (HttpsURLConnection)url.openConnection(); mWrapper = new HttpsUrlConnectionWrapper&lt;MyX509TrustManager, X509KeyManager, HostnameVerifier&gt;(conn, new MyX509TrustManager(context), null, null); } else if(murl.startsWith(&quot;http&quot;)){ HttpURLConnection conn = (HttpURLConnection)url.openConnection(); mWrapper = new HttpUrlConnectionWrapper(conn); } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public void setRequestMethod(DownLoadManager.RequsteMethod method) { mWrapper.setRequestMethod(method); } @Override public int getResponseCode() { return mWrapper.getResponseCode(); } @Override public void setDoOutPut(boolean newValue) { mWrapper.setDoOutPut(newValue); } @Override public InputStream getInputStream() { return mWrapper.getInputStream(); } @Override public void setConnectTimeout(int timeout) { mWrapper.setConnectTimeout(timeout); } @Override public void setReadTimeout(int timeout) { mWrapper.setReadTimeout(timeout); } @Override public void setRequestProperty(String range, String s) { mWrapper.setRequestProperty(range, s); } @Override public void disconnect() { mWrapper.disconnect(); } @Override public long getFileSize() { return mWrapper.getFileSize(); } } 到这里我们可以明确了，ConnectionWrapperManager都是假象，其实在Downloader中操作ConnectionWrapperManager，其实是在操作HttpURLConnection和HttpsURLConnection啦。 4.DownLoader续欢迎回来，现在我们继续看download方法里的内容了。先通过url来openConnection生成对应的URLConnection，然后设置get还是post，超时等，这些都是套路。当mDownLoadSize小于0的时候，就相当于是第一次下次并进行初始化执行openConnention方法。mDownLoadSize是个全局变量，下载的时候会变，而且这个值会同步数据库里的值，所以可以作为是否第一次下载的标识，当然后面还有更多用处。看看openConnention方法吧： private void openConnention(ConnectionWrapperManager manager) { try { if (mFileSize == 0) { mFileSize = manager.getFileSize(); } if (mFileSize &gt; 0) { isFolderExist(); mLocalFile = new RandomAccessFile(new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;), &quot;rwd&quot;); mSQLDownLoadInfo.setDownloadSize(mFileSize); if (isdownloading) { saveDownloadInfo(); } } } catch (FileNotFoundException e) { e.printStackTrace(); } } 做了几件事： 通过ConnectionWrapperManager获得文件的总大小，存到数据库里面去（前面说了有两个字段是还没有被赋初值的，忘了可以倒回去看看）。 新建下载的文件夹，不说了看代码吧。private boolean isFolderExist() { boolean result = false; try { String filepath = mFilePath; File file = new File(filepath); if (!file.exists()) { if (file.mkdirs()) { result = true; } } else { result = true; } } catch (Exception e) { e.printStackTrace(); } return result; } 生成了一个RandomAccessFile临时文件，这个非常牛逼，尤其是它的seek方法，可以说是断点续传的理论基础了。如果不是第一次下载，那就判断有没有那个临时文件了，如果有，那么mDownLoadSize也肯定有值，就seek到那个值然后继续下载吧，如果没有， 就相当于是第一次下啦。接下来就是下载更新回调的过程了，对照代码看看就行，反正都这样一个流程，再贴出来看看吧： inputStream = manager.getInputStream(); byte[] buffer = new byte[1024 * 4]; int length = -1; if (inputStream != null) { while ((length = inputStream.read(buffer)) != -1 &amp;&amp; isdownloading) { mLocalFile.write(buffer, 0, length); mDownLoadSize += length; mSafeDownLoadSize = mDownLoadSize; mHandler.sendEmptyMessage(TASK_PROGESS); } } 接下来是下载完了的操作，上代码： // 下载完了 if (mDownLoadSize == mFileSize) { boolean renameResult = renameFile(); if (renameResult) { mHandler.sendEmptyMessage(TASK_SUCCESS); // 转移文件成功 } else { new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;).delete(); Message msg = Message.obtain(); msg.what = TASK_ERROR; Bundle bundle = new Bundle(); bundle.putString(ERROR_KEY, &quot;转移文件失败&quot;); msg.setData(bundle); mHandler.sendEmptyMessage(TASK_ERROR);// 转移文件失败 } 简而言之，就是下完了之后重命名一下，然后根据重命名是否成功来发起成功或者失败的回调，下面是重命名的代码： private boolean renameFile() { File newfile = new File(mFilePath + File.separator + mFileName); if (newfile.exists()) { newfile.delete(); } File oldFile = new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;); return oldFile.renameTo(newfile); } 然后是清理战场了： // 清除数据库任务 mHelper.deleteDownLoadInfo(mSQLDownLoadInfo.getUserID(), getTaskID()); mDownLoadTask = null; mDownLoadCallBack = null; ondownload = false; mDownLoadSize = 0; mSafeDownLoadSize = 0; 如果下载过程中出错了，也是需要清理战场的，如果支持断点续传的话，还需要把已经下载的信息保存在数据库里面去： if (isdownloading) { if (mIsSupportBreakpoint) { try { if (mLocalFile != null) { long length = mLocalFile.length(); if (length &gt; 0) { saveDownloadInfo(); } } } catch (IOException e1) { e1.printStackTrace(); } } ondownload = false; mPool.remove(mDownLoadTask); mDownLoadTask.stopDownLoad(); mDownLoadTask = null; Message msg = Message.obtain(); msg.what = TASK_ERROR; Bundle bundle = new Bundle(); bundle.putString(ERROR_KEY, e.getMessage()); msg.setData(bundle); mHandler.sendMessage(msg); } final里面也关闭链接，关闭文件，也算是最后的清理了： finally { if (manager != null) { manager.disconnect(); } if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if (mLocalFile != null) { try { mLocalFile.close(); } catch (IOException e) { e.printStackTrace(); } } } 好了，主要代码贴完了，需要注意的是清理的时候有个mDownLoadTask.stopDownLoad();方法，照旧来看看： private void stopDownLoad() { isdownloading = false; if (mLocalFile != null) { long length = mSafeDownLoadSize; if (length &gt; 0) { if (mIsSupportBreakpoint) { saveDownloadInfo(); } else { clearDownLoadInfo(); } } } Message msg = Message.obtain(); msg.what = TASK_STOP; Bundle bundle = new Bundle(); bundle.putLong(STOP_KEY, mDownLoadSize); msg.setData(bundle); mHandler.sendMessage(msg); } 里面除了有个复制回调的handler发送消息外就是存储和清理数据库数据了，再来看看这两个方法： /** * 是否支持断点续传就在于中断下载是否保存下载信息 */ private void saveDownloadInfo() { if (mIsSupportBreakpoint) { mSQLDownLoadInfo.setDownloadSize(mSafeDownLoadSize); mSQLDownLoadInfo.setFileSize(mFileSize); mHelper.save(mSQLDownLoadInfo); } } private void clearDownLoadInfo() { mDownLoadSize = 0; mDownLoadCallBack = null; mHelper.deleteDownLoadInfo(mSQLDownLoadInfo.getUserID(), getTaskID()); File file = new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;); if (file.exists()) { file.delete(); } } 到目前为止，整个下载流程基本上也就是这个样子了，停止或者取消下载的时候这个类也提供一个公共方法来给外部调用，简单了解一下就行： public void stop() { if (mDownLoadTask != null) { ondownload = false; mDownLoadTask.stopDownLoad(); mPool.remove(mDownLoadTask); mDownLoadTask = null; } } public void destroy() { if (mDownLoadTask != null) { mDownLoadTask.stopDownLoad(); mPool.remove(mDownLoadTask); mDownLoadTask = null; } mHelper.deleteDownLoadInfo(mSQLDownLoadInfo.getUserID(), getTaskID()); File file = new File(mFilePath + File.separator + mFileName + &quot;.tmp&quot;); if (file.exists()) { file.delete(); } mDownLoadSize = 0; Message msg = Message.obtain(); msg.what = TASK_STOP; Bundle bundle = new Bundle(); bundle.putLong(STOP_KEY, mDownLoadSize); msg.setData(bundle); mHandler.sendMessage(msg); } 是不是看了这么多早就晕掉了，下载已经结束了，但感觉还有一块儿没有说到，是什么呢什么呢。 5.数据库对，就是它，它比较独立，就单独拧出来了，和下载其实没啥关系，但是为下载提供了持续存储，当然不仅仅是下载，太多时候各种业务需要它来提供持续了，感觉可以从零开始学习设计数据库。还是和上面一样，就截个类名看看就行了，这个结构稍微后面一点一点解释吧，虽然画个图会更好点。AbstractDatabaseHelper和BaseDBHelper是基类，前者提供数据库封装，后者提供业务封装。MyDatabaseHelper和DownloadTaskDBHelper分别负责继承他们，DownloadTaskDBHelper持有MyDatabaseHelper的实例，是不是觉得跟某个设计模式及其相似呢。不说了，上代码： public abstract class AbstractDatabaseHelper { /** */ /** * SQLite数据库实例 */ public SQLiteDatabase mDb = null; /** */ /** * 数据库创建帮手 */ protected CreateDBHelper mDbHelper = null; /** */ /** * 获得当前数据库帮手类标识(一般是该类名称)，用于日志等的记录 * * @return */ protected abstract String getTag(); /** */ /** * 获得数据库名称 * * @return */ protected abstract String getMyDatabaseName(); /** */ /** * 获得数据库版本，值至少为1。 当数据库结构发生改变的时候，请将此值加1，系统会在初始化时自动调用 * createDBTables和dropDBTables方法更新数据库结构。 * * @return */ protected abstract int getDatabaseVersion(); /** */ /** * 创建数据库表的SQL语句，一个元素一条语句 * * @return */ protected abstract String[] createDBTables(); /** */ /** * 删除数据库表的SQL语句，一个元素一条语句 * * @return */ protected abstract String[] dropDBTables(); /** */ /** * * TODO 内部数据库创建帮手类 * */ private class CreateDBHelper extends SQLiteOpenHelper { public CreateDBHelper(Context ctx) { super(ctx, getMyDatabaseName(), null, getDatabaseVersion()); } @Override public void onCreate(SQLiteDatabase db) { executeBatch(createDBTables(), db); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { Log.e(getTag(), &quot;Upgrading database &#39;&quot; + getMyDatabaseName() + &quot;&#39; from version &quot; + oldVersion + &quot; to &quot; + newVersion); for (int i = oldVersion; i &lt; newVersion; i++) { if (i &lt;= 14) { String[] tasks = { &quot;DROP TABLE IF EXISTS UPLOAD_TASK&quot;, &quot;DROP TABLE IF EXISTS FEED_COMMENT&quot;, &quot;DROP TABLE IF EXISTS SHARE&quot;, &quot;DROP TABLE IF EXISTS MESSAGE&quot;, &quot;DROP TABLE IF EXISTS CLIPS&quot; }; executeBatch(tasks, db); } else if (i &lt;= 16) { String[] updateClipTable = { &quot;ALTER TABLE CLIPS ADD COLUMN FAV_ID VARCHAR(32)&quot;, &quot;ALTER TABLE CLIPS ADD COLUMN TYPE INTEGER&quot; }; executeBatch(updateClipTable, db); } else if (i &lt;= 18) { db.execSQL(&quot;DROP TABLE IF EXISTS MESSAGE&quot;); } else if (i &lt;= 19) { db.execSQL(&quot;DROP TABLE IF EXISTS DOWNLOAD_TASK&quot;); } } onCreate(db); } /** */ /** * 批量执行Sql语句 * * @param sqls * @param db */ private void executeBatch(String[] sqls, SQLiteDatabase db) { if (sqls == null) return; db.beginTransaction(); try { int len = sqls.length; for (int i = 0; i &lt; len; i++) { db.execSQL(sqls[i]); } db.setTransactionSuccessful(); } catch (Exception e) { Log.d(getTag(), e.getMessage()); } finally { db.endTransaction(); } } } /** */ /** * 打开或者创建一个指定名称的数据库 * * @param dbName * @param ctx */ private synchronized void open(Context ctx) { if (mDbHelper == null) { try { mDbHelper = new CreateDBHelper(ctx); mDb = mDbHelper.getWritableDatabase(); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } } protected void init(Context ctx) { if (ctx == null) { throw new RuntimeException(&quot;ctx is null&quot;); } if (mDbHelper == null) { open(ctx); } } /** */ /** * 关闭数据库 */ public void close() { try { if (mDb != null &amp;&amp; mDb.isOpen()) { mDb.close(); } if (mDbHelper != null) { mDbHelper.close(); } } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } } AbstractDatabaseHelper里面有一个CreateDBHelper的内部类来继承SQLiteOpenHelper，然后里面就是标准的一些函数的实现啦。需要主要的是onUpgrade的实现跟业务有点关系，先不管，有兴趣可以自己了解，executeBatch支持批处理SQL语句，然后创建数据库等操作都是用虚函数的形势交给子类去实现的。那来看这个子类吧： public class MyDatabaseHelper extends AbstractDatabaseHelper { private static MyDatabaseHelper instance = null; private String databaseName = &quot;MYdb.db&quot;; private String tag = &quot;my_database&quot;; private int databaseVersion = 20; private Context context; @Override protected String[] createDBTables() { String[] object = { &quot;CREATE TABLE IF NOT EXISTS UPLOAD_TASK(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,TASK_ID VARCHAR(100)&quot; + &quot;,CREATE_TIME TIMESTAMP&quot; + &quot;,STATUS VARHCHAR(20)&quot; + &quot;,TAKS_BEAN BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS FEED_DETAIL(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,FEED_ID VARCHAR(100)&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,FEED_BEAN BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS SETTING(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,_KEY VARCHAR(100)&quot; + &quot;,_VALUE VARCHAR(100)&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS FEED_COLLECT(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,FAV_ID VARCHAR(32)&quot; + &quot;,AID VARCHAR(32)&quot; + &quot;,FEED_ID VARCHAR(100)&quot; + &quot;,SUBJECT VARCHAR(8)&quot; + &quot;,FEED_COLLECT BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS FEED_COMMENT(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,SID VARCHAR(32)&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,AID VARCHAR(32)&quot; + &quot;,CREATE_TIME TIMESTAMP&quot; + &quot;,FEED_COMMENT BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS SHARE(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,AID VARCHAR(32)&quot; + &quot;,SID VARCHAR(32)&quot; + &quot;,TYPE INTEGER&quot; + &quot;,CREATE_TIME TIMESTAMP&quot; + &quot;,SUBJECT VARCHAR(8)&quot; + &quot;,SHARE_BEAN BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS MESSAGE(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,CATEGORY INTEGER&quot; + &quot;,MESSAGE_ID VARCHAR(32)&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,STATUS INTEGER&quot; + &quot;,CREATE_TIME TIMESTAMP&quot; + &quot;,MESSAGE_BEAN BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS CLIPS(&quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,ARTICLE_ID VARCHAR(32)&quot; + &quot;,ARTICLE_INDEX INTEGER&quot; + &quot;,FAV_ID VARCHAR(32)&quot; + &quot;,TYPE INTEGER&quot; + &quot;,CREATE_TIME TIMESTAMP&quot; + &quot;,CLIPS_BEAN BLOB&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS DOWNLOAD_TASK( &quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL&quot; + &quot;,UID VARCHAR&quot; + &quot;,TASK_ID VARCHAR&quot; + &quot;,URL VARCHAR&quot; + &quot;,FILE_PATH VARCHAR&quot; + &quot;,FILE_NAME VARCHAR&quot; + &quot;,FILE_SIZE INTEGER&quot; + &quot;,DOWNLOAD_SIZE INTEGER&quot; + &quot;,IS_SUPPORT_BREAKPOINT INTEGER&quot; + &quot;)&quot;, &quot;CREATE TABLE IF NOT EXISTS TEST_CENTER( &quot; + &quot;ID INTEGER PRIMARY KEY AUTOINCREMENT&quot; + &quot;,UID VARCHAR(32)&quot; + &quot;,CENTER_ID VARCHAR(100)&quot; + &quot;,SUBJECT VARCHAR(32)&quot; + &quot;,CENTER_BEAN BLOB&quot; + &quot;)&quot; }; return object; } @Override protected String[] dropDBTables() { String[] object = { &quot;DROP TABLE IF EXISTS UPLOAD_TASK&quot;, &quot;DROP TABLE IF EXISTS FEED_DETAIL&quot;, &quot;DROP TABLE IF EXISTS SETTING&quot;, &quot;DROP TABLE IF EXISTS FEED_COLLECT&quot;, &quot;DROP TABLE IF EXISTS FEED_COMMENT&quot;, &quot;DROP TABLE IF EXISTS SHARE&quot;, &quot;DROP TABLE IF EXISTS MESSAGE&quot;, &quot;DROP TABLE IF EXISTS CLIPS&quot;, &quot;DROP TABLE IF EXISTS DOWNLOAD_TASK&quot;, &quot;DROP TABLE IF EXISTS CLIPS&quot;, &quot;DROP TABLE IF EXISTS TEST_CENTER&quot; }; return object; } @Override protected String getMyDatabaseName() { return databaseName; } @Override protected int getDatabaseVersion() { return databaseVersion; } @Override protected String getTag() { return tag; } private static synchronized void initSyn(Context context) { instance = new MyDatabaseHelper(context); } public static MyDatabaseHelper getInstance(Context context) { if (instance == null) { initSyn(context); } return instance; } private MyDatabaseHelper(Context context) { this.context = context; } public void execSQL(String sql, Object[] bindArgs) { init(context); if (mDb == null) { return; } try { mDb.execSQL(sql, bindArgs); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } public void execSQL(String[] sql, Object[][] bindArgs) { if (sql == null || sql.length == 0) { return; } init(context); if (mDb == null) { return; } for (int i = 0; i &lt; sql.length; i++) { try { mDb.execSQL(sql[i], bindArgs[i]); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } } public void execSQL(String sql) { init(context); if (mDb == null) { return; } try { mDb.execSQL(sql); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } public void update(String table, ContentValues values, String whereClause, String[] whereArgs) { init(context); if (mDb == null) { return; } try { mDb.update(table, values, whereClause, whereArgs); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } public Cursor rawQuery(String sql, String[] selectionArgs) { init(context); if (mDb == null) { return null; } return mDb.rawQuery(sql, selectionArgs); } public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) { init(context); if (mDb == null) { return null; } return mDb.query(table, columns, selection, selectionArgs, groupBy, having, orderBy); } } 子类除了根据业务创建了一大堆表之外，也实现了增删改查相关操作，通过名为mDb的SQLiteDatabase来进行操作，mDb是在父类初始化的时候就初始化好了的，可以代码倒回去看看，其他的也没什么了，接着看另外一个父类： public abstract class BaseDBHelper&lt;T&gt; { protected String getUserId() { String userId = &quot;12345&quot;;//UserManager.getCurUserId(); if (userId == null) { return null; } return userId; } public abstract String getTable(); public abstract void save(T obj); public abstract void update(T obj); public abstract void delete(String id); public abstract void deleteAll(); public abstract T find(String uid, String taskId); public abstract int getCount(); public abstract List&lt;T&gt; getAllData(); } UID是根据业务账号系统生成保存的，这里就用一个简单字符串代替就行了。就是一堆虚函数，这些就跟业务相关了，相当与这些方法会封装刚刚MyDatabaseHelper里面实现的增删改查方法。最后就是DownloadTaskDBHelper了： public class DownloadTaskDBHelper extends BaseDBHelper&lt;DownLoadBean&gt; { private static final String TABLE_NAME = &quot;DOWNLOAD_TASK&quot;; private static final int MAX_SAVE_TIME = 5; private volatile static DownloadTaskDBHelper mInstance; private MyDatabaseHelper mHelper; private int saveTime; private DownloadTaskDBHelper(Context context) { mHelper = MyDatabaseHelper.getInstance(context); } public static DownloadTaskDBHelper getInstance(Context context) { if (mInstance == null) { synchronized (DownloadTaskDBHelper.class) { if (mInstance == null) { mInstance = new DownloadTaskDBHelper(context); } } } return mInstance; } @Override public String getTable() { return TABLE_NAME; } @Override public void save(DownLoadBean obj) { String sql = &quot;insert into &quot; + getTable() + &quot;(&quot; + &quot;UID,TASK_ID,URL,FILE_PATH,FILE_NAME,FILE_SIZE,DOWNLOAD_SIZE,IS_SUPPORT_BREAKPOINT&quot; + &quot;)values(?,?,?,?,?,?,?,?)&quot;; Object[] bindArgs = { obj.getUserID(), obj.getTaskID(), obj.getUrl(), obj.getFilePath(), obj.getFileName(), obj.getFileSize(), obj.getDownloadSize(), obj.isSupportBreakpoint() == true ? 1 : 0 }; Cursor cursor = null; try { cursor = mHelper.rawQuery(&quot;SELECT * FROM &quot; + getTable() + &quot; WHERE UID = ? AND TASK_ID = ? &quot;, new String[] { obj.getUserID(), obj.getTaskID() }); if (cursor.moveToNext()) { update(obj); } else { mHelper.execSQL(sql, bindArgs); } } catch (Exception e) { saveTime++; if (saveTime &lt; MAX_SAVE_TIME) { save(obj); } else { saveTime = 0; } } finally { if (cursor != null) { cursor.close(); } } saveTime = 0; } @Override public void update(DownLoadBean obj) { String selection = null; String[] selectionArgs = null; selection = &quot;UID = ? AND TASK_ID = ?&quot;; selectionArgs = new String[] { obj.getUserID(), obj.getTaskID() }; ContentValues cv = new ContentValues(); cv.put(&quot;URL&quot;, obj.getUrl()); cv.put(&quot;FILE_PATH&quot;, obj.getFilePath()); cv.put(&quot;FILE_NAME&quot;, obj.getFileName()); cv.put(&quot;FILE_SIZE&quot;, obj.getFileSize()); cv.put(&quot;DOWNLOAD_SIZE&quot;, obj.getDownloadSize()); mHelper.update(getTable(), cv, selection, selectionArgs); } public List&lt;DownLoadBean&gt; findUserDownLoadInfo(String userID) { List&lt;DownLoadBean&gt; list = new ArrayList&lt;DownLoadBean&gt;(); String sql = &quot;SELECT * FROM &quot; + getTable() + &quot; WHERE UID = ?&quot;; Cursor cursor = null; try { cursor = mHelper.rawQuery(sql, new String[] { userID }); while (cursor.moveToNext()) { DownLoadBean downloadinfo = new DownLoadBean(); downloadinfo.setUserID(cursor.getString(cursor.getColumnIndex(&quot;UID&quot;))); downloadinfo.setTaskID(cursor.getString(cursor.getColumnIndex(&quot;TASK_ID&quot;))); downloadinfo.setUrl(cursor.getString(cursor.getColumnIndex(&quot;URL&quot;))); downloadinfo.setFilePath(cursor.getString(cursor.getColumnIndex(&quot;FILE_PATH&quot;))); downloadinfo.setFileName(cursor.getString(cursor.getColumnIndex(&quot;FILE_NAME&quot;))); downloadinfo.setFileSize(cursor.getLong(cursor.getColumnIndex(&quot;FILE_SIZE&quot;))); downloadinfo.setDownloadSize(cursor.getLong(cursor.getColumnIndex(&quot;DOWNLOAD_SIZE&quot;))); downloadinfo.setIsSupportBreakpoint(cursor.getLong(cursor.getColumnIndex(&quot;DOWNLOAD_SIZE&quot;)) &gt; 0 ? true : false); list.add(downloadinfo); } } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } finally { if (cursor != null) { cursor.close(); } } return list; } public DownLoadBean findDownLoadInfo(String userID, String taskID) { DownLoadBean downloadinfo = null; String sql = &quot;SELECT * FROM &quot; + getTable() + &quot; WHERE UID = ? AND TASK_ID = ?&quot;; Cursor cursor = null; try { cursor = mHelper.rawQuery(sql, new String[] { userID, taskID }); while (cursor.moveToNext()) { downloadinfo = new DownLoadBean(); downloadinfo.setUserID(cursor.getString(cursor.getColumnIndex(&quot;UID&quot;))); downloadinfo.setTaskID(cursor.getString(cursor.getColumnIndex(&quot;TASK_ID&quot;))); downloadinfo.setUrl(cursor.getString(cursor.getColumnIndex(&quot;URL&quot;))); downloadinfo.setFilePath(cursor.getString(cursor.getColumnIndex(&quot;FILE_PATH&quot;))); downloadinfo.setFileName(cursor.getString(cursor.getColumnIndex(&quot;FILE_NAME&quot;))); downloadinfo.setFileSize(cursor.getLong(cursor.getColumnIndex(&quot;FILE_SIZE&quot;))); downloadinfo.setDownloadSize(cursor.getLong(cursor.getColumnIndex(&quot;DOWNLOAD_SIZE&quot;))); downloadinfo.setIsSupportBreakpoint(cursor.getLong(cursor.getColumnIndex(&quot;DOWNLOAD_SIZE&quot;)) &gt; 0 ? true : false); } } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } finally { if (cursor != null) { cursor.close(); } } return downloadinfo; } public List&lt;DownLoadBean&gt; findAllDownLoadInfo() { List&lt;DownLoadBean&gt; list = new ArrayList&lt;DownLoadBean&gt;(); String sql = &quot;SELECT * FROM &quot; + getTable(); Cursor cursor = null; try { cursor = mHelper.rawQuery(sql, new String[] {}); while (cursor.moveToNext()) { DownLoadBean downloadinfo = new DownLoadBean(); downloadinfo.setUserID(cursor.getString(cursor.getColumnIndex(&quot;UID&quot;))); downloadinfo.setTaskID(cursor.getString(cursor.getColumnIndex(&quot;TASK_ID&quot;))); downloadinfo.setUrl(cursor.getString(cursor.getColumnIndex(&quot;URL&quot;))); downloadinfo.setFilePath(cursor.getString(cursor.getColumnIndex(&quot;FILE_PATH&quot;))); downloadinfo.setFileName(cursor.getString(cursor.getColumnIndex(&quot;FILE_NAME&quot;))); downloadinfo.setFileSize(cursor.getLong(cursor.getColumnIndex(&quot;FILE_SIZE&quot;))); downloadinfo.setDownloadSize(cursor.getLong(cursor.getColumnIndex(&quot;DOWNLOAD_SIZE&quot;))); downloadinfo.setIsSupportBreakpoint(cursor.getLong(cursor.getColumnIndex(&quot;DOWNLOAD_SIZE&quot;)) &gt; 0 ? true : false); list.add(downloadinfo); } } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } finally { if (cursor != null) { cursor.close(); } } return list; } public void deleteAllDownLoadInfo() { String sql = &quot;DELETE FROM &quot; + getTable(); mHelper.execSQL(sql); } public void deleteUserDownLoadInfo(String userID) { String sql = &quot;DELETE FROM &quot; + getTable() + &quot; WHERE UID = \\&quot;&quot; + userID + &quot;\\&quot;&quot;; mHelper.execSQL(sql); } public void deleteDownLoadInfo(String userID, String taskID) { String sql = &quot;DELETE FROM &quot; + getTable() + &quot; WHERE UID = \\&quot;&quot; + userID + &quot;\\&quot; AND TASK_ID = \\&quot;&quot; + taskID + &quot;\\&quot;&quot;; mHelper.execSQL(sql); } @Override public void delete(String id) { } @Override public void deleteAll() { } @Override public DownLoadBean find(String uid, String taskId) { return findDownLoadInfo(uid, taskId); } @Override public int getCount() { return 0; } @Override public List&lt;DownLoadBean&gt; getAllData() { return findAllDownLoadInfo(); } } 现在回去看下载的数据库相关操作，是不是就恍然大悟了，或者是标红的代码都不红了哈哈。 6.总结很长的一篇，基本上把所有代码都贴上来，本来就是以应用为导向，所以这样也是必须的，能把这些代码组合在一起就可以跑起来了。如果想把APP做大，那么下载模块和数据库模块都是必不可缺的，知道原理很重要，会应用也很重要，平时积累自己的兵器库关键时候随拿随用就更重要了，啊哈。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《Android技能树探索》基础篇---Service","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/《Android技能树探索》基础篇---Service/","text":"开始填坑了，刚开始肯定也是从最基本的东西开始撸，其实东西最后要归根究底都没有什么最基础的，总之是一次自我复习的过程，能够发散多少也要看了。为了不显得特别零散，尽量保持一篇一个主题吧，内容保持问答的方式，也供人产生更多发散。 1.Service有几种启动方式？Service是一个专门在后台处理长时间任务的Android组件，它没有UI。它有两种启动方式，startService和bindService。 startService只是启动Service，启动它的组件（如Activity）和Service并没有关联，只有当Service调用stopSelf或者其他组件调用stopService服务才会终止。bindService方法启动Service，其他组件可以通过回调获取Service的代理对象和Service交互，而这两方也进行了绑定，当启动方销毁时，Service也会自动进行unBind操作，当发现所有绑定都进行了unBind时才会销毁Service。 在这里再附上一张service的生命周期 2.bindService是怎么进行绑定的？和startService一样，bindService需要这样传参数：bindService(bindIntent, connection, BIND_AUTO_CREATE);，一个参数和startService传入的Intent一样，第二个参数是一个ServiceConnection的匿名类对象，一般可以如下声明 private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceDisconnected(ComponentName name) { } @Override public void onServiceConnected(ComponentName name, IBinder service) { myBinder = (MyService.MyBinder) service; myBinder.startDownload(); } }; 所以在需要启动的Service里面的onBind方法就不能返回null了 private MyBinder mBinder = new MyBinder(); @Override public IBinder onBind(Intent intent) { return mBinder; } class MyBinder extends Binder { public void startDownload() { Log.d(&quot;TAG&quot;, &quot;startDownload() executed&quot;); // 执行具体的下载任务 } } 在onServiceConnected里面返回的这个IBinder对象就是service中定义的那个，所以相当于是activity拿到了service暴露的方法接口，然后想怎么浪都随意了。第三个参数参考一下，一般用第一个flag BIND_AUTO_CREATE表示当收到绑定请求时，如果服务尚未创建，则即刻创建，在系统内存不足，需要先销毁优先级组件来释放内存，且只有驻留该服务的进程成为被销毁对象时，服务才可被销毁；BIND_DEBUG_UNBIND通常用于调试场景中判断绑定的服务是否正确，但其会引起内存泄漏，因此非调试目的不建议使用；BIND_NOT_FOREGROUND表示系统将阻止驻留该服务的进程具有前台优先级，仅在后台运行，该标志位在Froyo中引入。 3.bindService和startService的使用场景和注意事项？ 使用startService方式来启动Service时，生命周期是onCreate–&gt;onStartCommand，当在stopService之前多次startService会执行多次onStartCommand，但之后执行一次onCreate，使用stopService之后会调onDestroy。 使用bindService生命周期是onCreate，不会走onStartCommand，绑定成功会回调传入ServiceConnection的onServiceConnected的方法。 bindService一旦绑定成功就相当于activity和service进行了一次连接，要么主动unBindService，要么actvity销毁的时候也会自动解绑。一个service可以和多个activity进行绑定，相当于多个activity可以功能操作一个service，这个也是bindService的精髓了，当所有activity和service解绑了，这个service也会销毁。 如果我们既点击了Start Service按钮，又点击了Bind Service按钮，不管你是单独点击Stop Service按钮还是Unbind Service按钮，Service都不会被销毁，必要将两个按钮都点击一下，Service才会被销毁。也就是说，点击Stop Service按钮只会让Service停止，点击Unbind Service按钮只会让Service和Activity解除关联，一个Service必须要在既没有和任何Activity关联又处理停止状态的时候才会被销毁。 4.Service的onCreate回调函数可以做耗时的操作吗？Service和Thread之间没有任何关系，Service中执行的代码也都是在主线程中执行的。所以答案是不能。使用Service主要是满足多个activity关注一个后台事件（比如下载，心跳，横竖屏切换状态恢复等）和一些其他需求（多进程，多APP间通信等），一定要和多线程区分开。Service处理耗时操作同样是需要自己新开子线程来处理的，或者直接使用IntentService，可以直接在onHandleIntent方法里面处理耗时操作，里面东西设计到Handler的一些机制，后面有机会可以分析下，现在就不跑偏了。 5.Service的保活策略APP保活永远都是一场博弈论，Service保活作为一个小小分支主要也是了解了解。 将 Service 设置为 START_STICKY，利用系统机制在 Service 挂掉后自动拉活。 在service 的onDestory里面重启服务。 创建前台Service。可以通过以下方式来创建一个前台Service```public class MyService extends Service { public static final String TAG = “MyService”; private MyBinder mBinder = new MyBinder(); @Override public void onCreate() { super.onCreate(); Notification notification = new Notification(R.drawable.ic_launcher, &quot;有通知到来&quot;, System.currentTimeMillis()); Intent notificationIntent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0); notification.setLatestEventInfo(this, &quot;这是通知的标题&quot;, &quot;这是通知的内容&quot;, pendingIntent); startForeground(1, notification); Log.d(TAG, &quot;onCreate() executed&quot;); } ……… }``` 6.Service进程间通信前面说到Service中执行耗时操作会阻塞UI线程导致ANR的，但是在注册Service的时候声明一下android:process=&quot;:remote&quot;就不会ANR了。因为这样Service就会运行到其他进程中，虽然还是阻塞了线程，不过倒不会影响到界面中去。但是这种情况想要通过bindService来启动就万万不行了，华丽丽地会挂吧。针对于Service进程间通信安卓给出了很好的解决方案—AIDL。这种进程间（也可以是APP间）的通信方案在很多地方都有用武之地的，一般都是Messenger&amp;AIDL。大概流程就是自定义AIDL接口，系统会自动生成对应的JAVA类，这个类作为binder的子类可以通过bindService的方式传给activity，需要注意以下几点： 在两个APP中都是用同一份AIDL文件，然后通过bindService的方式就可以进行通信，主要包名路径名也需要是一样的。 再不同APP中，bindService的第一个参数那个intent需要使用隐式的action来启动，5.0后系统不允许隐式启动service，不过并没什么关系，网上搜索是有解决方案的。 AIDL一般只能传递Java的基本数据类型、字符串、List或Map，传递自定义类型可以实现Parcelable接口。 参考博客http://blog.csdn.net/guolin_blog/article/details/11952435http://www.jianshu.com/p/7a7db9f8692d?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qqhttp://blog.csdn.net/lmj623565791/article/details/47143563","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"基于Fragment的安卓插件化Demo","date":"2017-03-31T16:00:00.000Z","path":"2017/04/01/基于Fragment的安卓插件化Demo/","text":"说明:本篇文章主要以代码的形式还原结构，并非从原理的角度来阐述插件化，相关原理请自行谷歌。 1.工程总体结构 app是主module，也就是唯一一个配置成com.android.application的module，里面是不需要插件化的主页面等。 bbcomm是公共依赖库，里面放一些app或者其他插件都会用到的公共资源与控件。 login是没有被插件化的模块，作为app的依赖库，本质上和app没什么区别。 p_scanword是插件。 pluginbase是插件框架。 2.依赖关系 app依赖bbcomm（如果需要使用公共控件）和login bbcomm依赖pluginbase login依赖bbcomm（如果需要使用公共控件） p_scanword依赖bbcomm（如果需要使用公共控件） pluginbase不依赖任何其他 3.从零开始 新建一个app的module，类型是application，正常新建一个activity，打造万能测试页面，如下图所示：稍微解释下这个页面的元素： 第一个button是跳转到login里面的另一个activity的。 第二个button加载插件，把插件的页面展示到下面那个蓝色的layout里面去。 第三个button来自于bbcomm，同时插件里也使用了bbcomm里面的这个控件。 一个button没什么好说的，代码如下 Intent loginIntent = new Intent(MainActivity.this,LoginMainActivity.class); startActivity(loginIntent); 在pluginbase里面先定义一个PluginInfo的实体类，里面包含了插件的相关信息，如下： public class PluginInfo { public String name; public String libDir; public ClassLoader loader; public Resources resources; public Resources.Theme theme; public PluginBase pluginBase; public Context context; } 其他基本都是基本类型或者安卓基本类型，那么PluginBase是什么东西呢？先看看PluginBase里面的代码 public abstract class PluginBase { public static final String PLUGIN_SCANWORD = &quot;p_scanword&quot;; private static Context mContext; private FragmentManager mFragmentManager; private Context pluginContext; public void attach(Context context, FragmentManager manager) { mContext = context.getApplicationContext(); mFragmentManager = manager; init(); } public Context getHostContext() { return mContext; } public Context getPluginContext(){ if(pluginContext != null){ return pluginContext; } pluginContext = PluginManager.getInstance(mContext).makePluginContext(getPluginName(), mContext); return pluginContext; } protected FragmentManager getFragmentManager() { return mFragmentManager; } protected FragmentTransaction getFragmentTransaction(){ FragmentManager fragmentManager = getFragmentManager(); return fragmentManager.beginTransaction(); } public abstract String getPluginName(); public abstract void init(); public abstract void show(int containerId); public abstract void hide(); public abstract void detach(); } 可以看出来，PluginBase是一个虚类，里面声明了若干的虚函数，有一个attch的公共方法来接收宿主的context和FragmentManager，并且提供公共方法让外部使用这两个属性，此外还实现了一个getPluginContext的方法，这个方法可以获得插件的context，对于插件化具有重要的意义。说到getPluginContext方法，可以看看里面的实现，其实主要就是PluginManager.getInstance(mContext).makePluginContext(getPluginName(), mContext);这句话没错吧。然后就可以看看PluginManager是什么鬼了。 其实分123并没有啥卵用，只是为了稍微有点层次感不至于太累，好了继续吧。PluginManager既然是manager一般是单例的，所以首先是这样： private PluginManager(Context context) { this.appContext = context.getApplicationContext(); } public static PluginManager getInstance(Context context) { if (sInstance == null) { synchronized (PluginManager.class) { if (sInstance == null) { sInstance = new PluginManager(context); } } } return sInstance; } 这个没啥好说的，接下来看看刚刚那个makePluginContext方法: public Context makePluginContext(final String name, final Context outerContext) { if (isPluginTestMode) { return outerContext; } Context context = mPluginMap.get(name).context; if (context != null) { return context; } context = new ContextWrapper(outerContext) { @Override public Resources getResources() { return mPluginMap.get(name).resources; } @Override public AssetManager getAssets() { return mPluginMap.get(name).resources.getAssets(); } @Override public Resources.Theme getTheme() { return mPluginMap.get(name).theme; } @Override public Object getSystemService(String name) { if (!Context.LAYOUT_INFLATER_SERVICE.equals(name)) { return super.getSystemService(name); } LayoutInflater inflater = (LayoutInflater) super.getApplicationContext() .getSystemService(Context.LAYOUT_INFLATER_SERVICE); LayoutInflater proxyInflater = inflater.cloneInContext(this); return proxyInflater; } }; return context; } isPluginTestMode这里可以先不管，我们可以看到这个context其实是根据name在一个名为mPluginMap的容器里面取出来的，如果取出为空就new一个ContextWrapper重新创建，并在各个重写方法里面都使用mPluginMap的值，这里需要注意的是getSystemService方法的重写，这样就能保证在使用LayoutInflater的时候能够使用正确的context而不会出错。接下来需要看看mPluginMap是什么了吧，里面的数据是怎么放进去的。首先看看声明： private final Map&lt;String, PluginInfo&gt; mPluginMap = new HashMap&lt;String, PluginInfo&gt;(); 所以mPluginMap就是一个hashmap，key就是插件对应的name，而value就是插件对应的PluginInfo。来看看是怎么把数据塞进去的： public PluginInfo getPluginInfo(String pluginName) { if (mPluginMap.containsKey(pluginName)) { return mPluginMap.get(pluginName); } String pluginPath = getPluginPath(pluginName); PluginInfo pluginInfo = null; try { pluginInfo = loadPluginInfo(pluginName, pluginPath); } catch (Exception e) { e.printStackTrace(); } if (pluginInfo != null) { mPluginMap.put(pluginName, pluginInfo); } return pluginInfo; } 这种东西其实就像玩RPG游戏一样，游戏刚开始可能主角只想完成一个单纯的任务A，而在完成A的途中发现需要完成B，完成B的途中又要完成C才行，以此类推，所以一个游戏的任务链是A-&gt;B-&gt;C-&gt;…..-&gt;C-&gt;B-A，吐槽而已，同理，从代码中看到了其实核心方法是loadPluginInfo，而它的参数又由getPluginPath提供，所以先看看getPluginPath的内部代码吧： private String getPluginPath(String pluginName) { File dir = new File(appContext.getFilesDir(), PLUGIN_DIR); if (!dir.exists()) { dir.mkdirs(); } File saveFile = new File(dir, pluginName + &quot;.apk&quot;); // pluginA.apk if (saveFile != null &amp;&amp; saveFile.exists() &amp;&amp; saveFile.isFile()) { saveFile.setExecutable(true); return saveFile.getAbsolutePath(); } return null; } 里面的appContext是在初始化单例的时候传入的宿主context，代码上面已经有了，来看下上面这个方法，我们从特定的目录中去取插件的apk，如果有则返回插件的路径，没有则返回空。好了，终于可以看loadPluginInfo方法了。 private PluginInfo loadPluginInfo(String pluginName, String pluginPath) throws ClassNotFoundException, InstantiationException, IllegalAccessException { String optDir = getPluginOptDir(pluginName); String libDir = getPluginLibDir(pluginName); DexClassLoader dexClassLoader = createDexClassLoader(pluginPath, optDir, libDir); AssetManager assetManager = createAssetManager(pluginPath); Resources resources = createResources(assetManager); PluginInfo pluginInfo = new PluginInfo(); pluginInfo.libDir = libDir; pluginInfo.loader = dexClassLoader; pluginInfo.resources = resources; Resources.Theme theme = resources.newTheme(); theme.setTo(appContext.getTheme()); pluginInfo.theme = theme; Class cls = Class.forName(getPluginLauncherName(pluginName), true, dexClassLoader); PluginBase pluginBase = (PluginBase) cls.newInstance(); pluginInfo.pluginBase = pluginBase; return pluginInfo; } 核心来了！！首先通过getPluginOptDir和getPluginLibDir这两个方法新建和指定下opt和dir的目录，代码如下： private String getPluginOptDir(String name) { File dir = new File(appContext.getFilesDir(), &quot;/plugin/&quot; + name + &quot;/opt&quot;); dir.mkdirs(); return dir.getAbsolutePath(); } private String getPluginLibDir(String name) { File dir = new File(appContext.getFilesDir(), &quot;/plugin/&quot; + name + &quot;/libs&quot;); dir.mkdirs(); return dir.getAbsolutePath(); } 然后通过 private DexClassLoader createDexClassLoader(String pluginPath, String optDir, String libDir) { return new DexClassLoader(pluginPath, optDir, libDir, appContext.getClassLoader()); } 这个方法把pluginPath，optDir，libDir注入到dexClassLoader中生成新的classLoader，这个classLoader就会在我们指定的目录下面去找dex文件加载，这便是插件化中java代码插件化的原理了。除了Java代码，当然还有资源文件，看到这两行代码木有： AssetManager assetManager = createAssetManager(pluginPath); Resources resources = createResources(assetManager); 我们会构造一个resources出来，这个就是插件的resources的啦，那是怎么构造出来的呢，接着看： private AssetManager createAssetManager(String dexPath) { try { AssetManager assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); addAssetPath.invoke(assetManager, dexPath); return assetManager; } catch (Exception e) { e.printStackTrace(); return null; } } private Resources createResources(AssetManager assetManager) { Resources superRes = appContext.getResources(); Resources resources = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration()); return resources; } 第一个方法是通过反射把插件路径注入到assetManager中生成能够支持插件assetManager，然后用这个assetManager重新构造出一个resources。好了，万事俱备了，可以构建pluginInfo了，翻上去看代码就懂了，然后会反射出一个PluginBase给pluginInfo的PluginBase赋值，看看是怎么反射出来的: private String getPluginLauncherName(String pluginName) { return new StringBuffer(&quot;com.example.xunwang.&quot;).append(pluginName).append(&quot;.LauncherPlugin&quot;).toString(); } 是不是代码不要太简单，其实拼的这个字符串是我们每一个插件的入口，所以在每一个插件的这个路径下必须要有这样一个入口，不然当然就反射不到啦，再就是LauncherPlugin必须是继承PluginBase的，这个不用多说吧。到现在为止PluginInfo已经全部初始化完毕了，是不是都忘了最开始要干啥了。 经过上面的分析可能有点小晕了，还记得getPluginPath这个方法吗，不记得了翻回去看看，注意File dir = new File(appContext.getFilesDir(), PLUGIN_DIR);和File saveFile = new File(dir, pluginName + &quot;.apk&quot;);这两句话，其实这个路径是在getFilesDir()的PLUGIN_DIR文件夹下找pluginName.apk这个文件。但是其实打包脚本是把插件的apk打包到app这个module的asset目录下的，那么就需要作一个拷贝操作了，也就是PluginManager的loadPlugins方法了： public void loadPlugins(String[] pluginNames) { PluginLoader pluginLoader = new PluginLoader(appContext); pluginLoader.setPluginLoaderListener(new PluginLoader.PluginLoaderListener() { @Override public void loadResult(String[][] results) { Log.e(TAG &quot;loadPlugins finished&quot;); if (results == null) { return; } for (int i = 0; i &lt; results.length; i++) { Log.e(TAG, results[i][0] + &quot;:&quot; + results[i][1]); } } }); pluginLoader.execute(pluginNames); } 执行了一个名叫PluginLoader的异步操作，里面有一个加载完成的回调，所谓的加载也就是把asset目录下插件的apk拷贝到getFilesDir()的PLUGIN_DIR目录下而已，不说了上代码： public class PluginLoader extends AsyncTask&lt;String, Void, String[][]&gt; { public static final String PLUGIN_DIR = &quot;plugin&quot;; private Context mContext; private PluginLoaderListener pluginLoaderListener; public interface PluginLoaderListener { public void loadResult(String[][] result); } public void setPluginLoaderListener(PluginLoaderListener pluginLoaderListener) { this.pluginLoaderListener = pluginLoaderListener; } public PluginLoader(Context context) { this.mContext = context; } @Override protected String[][] doInBackground(String... params) { if (params == null || params.length == 0) { return null; } String[][] results = new String[params.length][2]; for (int i = 0; i &lt; params.length; i++) { String apkPath = null; try { apkPath = loadPlugin(params[i]); } catch (Exception e) { e.printStackTrace(); } results[i][0] = params[i]; results[i][1] = apkPath; } return results; } private String loadPlugin(String plugName) throws Exception { File dir = new File(mContext.getFilesDir(), PLUGIN_DIR); dir.mkdirs(); File saveFile = new File(dir, plugName + &quot;.apk&quot;); saveFile.setExecutable(true); FileOutputStream outputStream = null; InputStream inputStream = null; try { int count = 0; byte[] buf = new byte[1024]; inputStream = mContext.getAssets().open(plugName + &quot;.apk&quot;); outputStream = new FileOutputStream(saveFile); while ((count = inputStream.read(buf)) &gt; 0) { outputStream.write(buf, 0, count); } } finally { inputStream.close(); outputStream.close(); } Log.e(TAG, &quot;load pulgin write: &quot; + saveFile.length()); return saveFile.getAbsolutePath(); } @Override protected void onPostExecute(String[][] result) { if (pluginLoaderListener != null) { pluginLoaderListener.loadResult(result); } } } loadPlugins通常在Application的时候就做这个操作，把所有的插件名放到一个数组中就行了： private String[] plugins = { PluginBase.PLUGIN_SCANWORD }; PluginManager.getInstance(getApplicationContext()).loadPlugins(plugins); 到现在为止，又完成一大步了，我们来看看pluginbase这个module的文件后面四个文件上面基本上都了解完了，最后来看看PlugFragment吧。```javapublic abstract class PlugFragment extends Fragment { private Context context; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); context = PluginManager.getInstance(getActivity()).makePluginContext(getPluginName(), getActivity()); } public Context getContext(){ return context; } protected abstract String getPluginName(); } 它是所有插件里面fragment的基类，封装了context为插件的context，里面的实现前面也详细了解过了，所以PluginBase这个module就是这些啦，接下来看看插件模块应该怎么写。 6. 我们的插件名为`p_scanword`，这个名字必须和PluginBase类里面定义的插件名常量的名字是一样的，为什么呢，因为反射啊。而包名是`com.example.xunwang.scanword`,这个不用纠结了，如果后面有机会了解这个打包脚本再说吧。 还记得前面说的每个插件的入口类吗，没错就是它`LauncherPlugin`。 ```java public class LauncherPlugin extends PluginBase { public static int CONTAINER_ID; private Fragment mFragment; @Override public String getPluginName() { return PLUGIN_SCANWORD; } @Override public void init() { mFragment = new DefaultFragment(); } @Override public void show(int containerId) { CONTAINER_ID = containerId; FragmentTransaction ft = getFragmentTransaction(); ft.replace(containerId, mFragment); ft.commitAllowingStateLoss(); } @Override public void hide() { if(mFragment.getView() != null){ mFragment.getView().setVisibility(View.INVISIBLE); } } @Override public void detach() { getFragmentTransaction().detach(mFragment).commit(); } } 可能看到这个还不是特别清楚，那再看看我在点击第二个button的时候在onclick里面做了啥事（不记得第二个button是干什么的翻到最前吧）: PluginInfo pluginInfo = PluginManager.getInstance(getApplicationContext()).getPluginInfo( PluginBase.PLUGIN_SCANWORD); Log.d(&quot;kkkkkkkk&quot;, &quot;pluginInfo --&gt; &quot; + pluginInfo); PluginBase pluginBase = null; if (pluginInfo != null) { pluginBase = pluginInfo.pluginBase; } if (pluginBase == null) { Toast.makeText(getApplicationContext(), &quot;plugin not loaded&quot;, Toast.LENGTH_SHORT).show(); return; } pluginBase.attach(MiniXbjMainActivity.this, getSupportFragmentManager()); pluginBase.show(R.id.plugin_layout); 看到没有，第4段写了那么那么多，几乎整个PluginManager都是为了在构建PluginInfo这个东东，这个地方终于用了。然后取出PluginInfo里面的pluginBase，是怎么生成的倒回去看吧，简而言之，就是通过PluginBase.PLUGIN_SCANWORD绕了好大一圈反射出了插件中的LauncherPlugin这个类，然后调了LauncherPlugin类的attach和show两个方法，attach之前我们说了其实是PluginBase的，相当于把宿主的context和FragmentManager传给插件，而show就是通过传进来的FragmentManager获得FragmentTransaction,然后使用replace实现显示插件页面的效果。所以LauncherPlugin作为入口类一般是一个壳，生成的真正插件主页的fragment在它的init方法里获得，这里也就是DefaultFragment啦。最后来看看DefaultFragment吧。 public class DefaultFragment extends PlugFragment { @Override protected String getPluginName() { return PluginBase.PLUGIN_SCANWORD; } @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { LayoutInflater factory = LayoutInflater.from(getContext()); ViewGroup viewGroup = (ViewGroup) factory.inflate(R.layout.pla_linear, container, false); return viewGroup; } } LayoutInflater的时候是不是传入的context不一样啦，其实也看不出来，其实它是plugFragment包装的那个插件context，因为pla_linear在插件的module里，不用插件的context绝逼是找不到的。再次强调插件开发的规则，宿主的资源使用宿主的context，插件的资源使用插件的context，公共组件的资源也使用宿主的context(因为在打包过程中，公共组件不打到插件中而是打到宿主中)，这个很重要，谁用谁知道。到目前为止一个插件框架的基本雏形已经出来了，最后来看看bbcomm吧，我在项目里面添加了一个自定义view public class CommButtonView extends Button { private Drawable bg; private Paint paint; public CommButtonView(Context context) { super(context); init(context); } public CommButtonView(Context context, AttributeSet attrs) { super(context, attrs); init(context); } public CommButtonView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context); } private void init(Context context) { bg = context.getApplicationContext().getResources().getDrawable(R.drawable.audio_play_bg); paint = new Paint(); paint.setColor(Color.RED); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawBitmap(((BitmapDrawable)bg).getBitmap(), 0, 0 , paint); } } audio_play_bg这张图片放到bbcomm的module里的，注意到context没有，一言不合就会crash哟。宿主和插件由于都是依赖bbcomm的，所以都正常使用这个自定义控件就行了，最后上一张图吧。 总结:以上写了一大堆，也只不过是插件化的最基本雏形而已，但同时也是基础，虽然基于fragment的插件化目前已不再主流，但再某些地方总是会有用武之地，后面还有很长的路要走，多多站在巨人和别人的肩膀上会走得更快。 PS：本文仅作为学习之用，不提供代码，禁止转载，敬请谅解。","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"Android深度主题切换探究","date":"2017-03-20T16:00:00.000Z","path":"2017/03/21/Android深度主题切换探究/","text":"写在最前：目前市面上比较成熟的资讯类APP都会有夜间模式，一些偏娱乐的APP甚至会有多主体切换功能。网上关于主题的相关文章可能也不少了，其实单纯关于整体色调的改变并实现起来并不困难。本文讨论一种更加深度主题的切换，即页面上的所有元素（包括文字颜色，图片，字符串等）都能够根据不同的主题使用而不同，并且每个主题包是独立于APP本身的，可以从服务器上下载下来（也是一个APK文件），然后类似于插件资源的加载，根于业务来应用某一个APK里面的对应主题资源。 1.一个从零开始的demo这次的demo有两个页面，首页是SkinApplyMainActivity，xml布局长这样这里有必要说明下这个layout里面对应控件的id，后面会用到： 最外面是一个LinearLayout，id是skin_root_layout。 上面的TextView的id是skin_text1。 下面的Button的id为next_page。命名不是很规范，将就看了。 点击button，跳转到另一个名为OtherActivity的activity。看看这个OtherActivity: 最外层的LinearLayout叫root_layout。 第一个Button的id是skin_default_theme_btn。 第二个Button的id是skin_new_theme_btn。 下面还有张图片，叫做skin_other_img。页面相关的先介绍到这里，需要主要的是，这两个activity继承一个基类BaseActivity，这个基类主要是保证子类具有更换主题的能力，所以重点就在这里了，先贴出来溜溜：```javapublic class BaseActivity extends Activity implements ISkinUpate { private List customValues; private String baseLastThemeId; public void onResume() { super.onResume(); updateTheme(); } protected SkinPackageManager getSkinPackageManager() { return SkinPackageManager.getInstance(this); } public List getSkinCustomValues() { return customValues; } @Override public boolean updateTheme() { if (!applyTheme()) { return false; } if (isThemeApplied()) { return false; } SkinPackageManager skinManager = SkinPackageManager.getInstance(getApplicationContext()); baseLastThemeId = skinManager.getCurSkinTheme(); customValues = SkinApplyHandler.applySkin(this, this.getClass().getSimpleName(), getWindow().getDecorView()); return true; } /** 主题是否已应用 @return*/public boolean isThemeApplied() { SkinPackageManager skinManager = SkinPackageManager.getInstance(getApplicationContext()); if (skinManager.getCurSkinTheme().equals(baseLastThemeId)) { return true; } return false;} @Overridepublic boolean applyTheme() { return true;} } 通过这个类我们可以比较容易看出核心所在，就这几个类没跑了，它们是`ISkinUpate`,`SkinPackageManager`和`SkinApplyHandler`,把这三个东东搞定了，这篇文章也就差不多了，那么撸起袖子，换一小节接着来吧。 #### 2.主题应用的几把刀 一切还是从`BaseActivity`说起吧，从刚刚上面的代码我们可以看到在`onResume`里面调用了一个`updateTheme`方法，这是一个接口的重载方法，先看这个`ISkinUpate`吧： ```java public interface ISkinUpate { public abstract boolean updateTheme(); abstract boolean applyTheme(); } 第一个就是我们在基类实现的应用主题的核心方法，第二个是用来控制是否应用主题的。回到BaseActivity里面来，看到updateTheme里面首先有两个判断，第一个当然就是说，如果不应用主题当然就不继续执行下去了，那么isThemeApplied方法是什么呢，看代码简单猜一下其实很容易看出来，就是应用主题的时候会看看需要应用的主题是不是就是当前主题，如果是就不需要继续应用了，性能能省则省对吧。然后可以看看SkinPackageManager了，又是一个manager，套路已经很深了，所以它首先肯定是这样的： public static SkinPackageManager getInstance(Context mContext) { if (mInstance == null) { synchronized (lock) { if (mInstance == null) { mInstance = new SkinPackageManager(mContext); } } } return mInstance; } 接下来应该关注下它的构造方法： private SkinPackageManager(Context mContext) { this.mContext = mContext; try { File file = Environment.getExternalStorageDirectory();//mContext.getFilesDir(); if (file != null) { file = new File(file, SKIN_DIR); if (!file.exists()) { file.mkdirs(); } themeRootPath = file.getAbsolutePath(); } } catch (Exception e) { } } 构造函数初始化了themeRootPath变量，这个变量就是指向主题APK的绝对路径。然后我们看到BaseActivity里面的updateTheme首先是调用了getCurSkinTheme方法，那我们来看看： public String getCurSkinTheme() { if (curTheme == null) { curTheme = SPSetting.getAppSkinTheme(); } if (curTheme == null) { curTheme = DEFAULT_THEME; } return curTheme; } SPSetting就是SharedPreferences啦，在这里插播一下SP的设计封装。看看SPSetting里面的代码： public class SPSetting { public static final String SETTING = &quot;setting&quot;; private static final String SKIN_THEME = &quot;skin_theme&quot;; public static void saveAppSkinTheme(String theme) { PrefsMgr.putString(SETTING, SKIN_THEME, theme); } public static String getAppSkinTheme() { return PrefsMgr.getString(SETTING, SKIN_THEME, null); } } 很明显它是封装了具体业务的，然后使用了一个PrefsMgr的类，那来看看这个： public class PrefsMgr { public static int getInt(String tbl, String key, int def) { if (MyApplication.getInstance() == null) { return def; } SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); return prefs.getInt(key, def); } public static long getLong(String tbl, String key, long def) { if (MyApplication.getInstance() == null) { return def; } SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); return prefs.getLong(key, def); } public static String getString(String tbl, String key, String def) { if (MyApplication.getInstance() == null) { return def; } SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); return prefs.getString(key, def); } public static boolean getBoolean(String tbl, String key, boolean def) { if (MyApplication.getInstance() == null) { return def; } SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); return prefs.getBoolean(key, def); } public static float getFloat(String tbl, String key, float def) { if (MyApplication.getInstance() == null) { return def; } SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); return prefs.getFloat(key, def); } public static void putInt(String tbl, String key, int value) { SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); SharedPreferences.Editor editor = prefs.edit(); editor.putInt(key, value); editor.apply(); } public static void putLong(String tbl, String key, long value) { SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); SharedPreferences.Editor editor = prefs.edit(); editor.putLong(key, value); editor.apply(); } public static void putString(String tbl, String key, String value) { SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); SharedPreferences.Editor editor = prefs.edit(); editor.putString(key, value); editor.apply(); } public static void putBoolean(String tbl, String key, boolean value) { SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); SharedPreferences.Editor editor = prefs.edit(); editor.putBoolean(key, value); editor.apply(); } public static void putFloat(String tbl, String key, float value) { SharedPreferences prefs = MyApplication.getInstance().getWenbaSharedPreferences(tbl); SharedPreferences.Editor editor = prefs.edit(); editor.putFloat(key, value); editor.apply(); } } 原来如此，PrefsMgr封装的才是真正的sp，然后SPSetting做了二次业务封装，以后有相关的sp需求就统一在SPSetting管理就行了，简单而实用吧。最后补上在Application里面获得SP实例的代码： public SharedPreferences getWenbaSharedPreferences(String tbl) { return getSharedPreferences(tbl, Context.MODE_PRIVATE); } 回到BaseActivity里的updateTheme，通过getCurSkinTheme方法取得当然的主题，在这之前会用isThemeApplied判断当前主题是否跟上一次主题一样的，如果是就不继续应用了。所以真正的核心就是customValues = SkinApplyHandler.applySkin(this, this.getClass().getSimpleName(), getWindow().getDecorView());这句话没跑啦。直接上代码先： public static List&lt;CustomValue&gt; applySkin(Context context, String skinConfigName, View rootView) { if (sCommonConfig == null) { initCommonConfig(context); } return new SkinApply(context, skinConfigName, sCommonConfig, rootView).apply(); } sCommonConfig是个标识为，如果为空就调用initCommonConfig方法，这个方法一会儿再看，先继续往下走到return的那个地方，new了一个名为SkinApply的类，并且调用了apply方法。看来核心真心还隐藏得挺深的，层层剥开吧。 public SkinApply(Context context, String skinConfigName, ThemeConfig commConfig, View rootView) { this.context = context; this.rootView = rootView; this.skinConfigName = skinConfigName; this.commConfig = commConfig; this.mSkinPackageManager = SkinPackageManager.getInstance(context); } 构造函数里面初始化了一些变量，当然后面是又用的，直接看看apply方法是干什么的就好。 public List&lt;CustomValue&gt; apply() { ThemeConfig thisConfig = null; try { // get specific name String fileName = &quot;skin/config/&quot; + skinConfigName + &quot;.xml&quot;; thisConfig = SkinApplyHandler.parseThemeAsset(context, fileName); if (thisConfig == null) { Log.d(&quot;skin&quot;, &quot;no config skinConfigName = &quot; + skinConfigName); // apply common config applyThemeConfig(commConfig); return null; } if (thisConfig.applyCommonAttrbiute) { applyThemeConfig(commConfig); } applyThemeConfig(thisConfig); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } return thisConfig.customValueList; } 这里也有comm相关的字眼，那只能简单说一下了，commConfig也就是从刚刚外面传进来的，相当于是一个页面的公共配置，在这里配一下就相当于在每个使用主题的页面都使用这个主题配置了，和基类子类的概念差不多，基类的行为是所有子类公共的，子类的行为是自己所独有的。所以现在来看apply的代码还是比较清晰了吧。 首先在特定的文件目录下面去找特定名称的xml。 然后SkinApplyHandler.parseThemeAsset获得自己特定的config，如果为空则只加载公共的主题配置，如果不为空则先加载公共的，在加载自己的。这个config的类型是ThemeConfig，可以来看看了： public static class ThemeConfig { public static final String NODE_THEME_ROOT = &quot;ThemeRoot&quot;; public static final String NODE_COLORS = &quot;colors&quot;; public static final String NODE_DRAWABLES = &quot;drawables&quot;; public static final String NODE_STRINGS = &quot;strings&quot;; public static final String NODE_APPLY_COMMON_ATTRIBIUTE = &quot;applyCommonAttrbiute&quot;; public static final String NODE_CONFIG_ITEM = &quot;ConfigItem&quot;; public static final String NODE_METHOD_CALL = &quot;MethodCall&quot;; public static final String NODE_CUSTOM_VALUE = &quot;CustomValue&quot;; public static final String NODE_VALUE_DEF = &quot;ValueDef&quot;; public static final String ATTR_VIEW_ID = &quot;viewId&quot;; public static final String ATTR_METHOD = &quot;method&quot;; public static final String ATTR_RES_NAME = &quot;resName&quot;; public static final String ATTR_SPECIAL_THEME = &quot;specialTheme&quot;; public static final String ATTR_NAME = &quot;name&quot;; public static final String ATTR_VALUE = &quot;value&quot;; public static final String ATTR_TYPE = &quot;type&quot;; public boolean applyCommonAttrbiute; public List&lt;ConfigItem&gt; colorList; public List&lt;ConfigItem&gt; drawableList; public List&lt;ConfigItem&gt; stringList; public List&lt;CustomValue&gt; customValueList; } 看上去很复杂对吧，那先不管吧，继续看上一步。apply方法里面现在有两个核心的方法parseThemeAsset和applyThemeConfig，先看第一个： /** * 格式皮肤配置xml，转化为ThemeConfig Bean * * @param name * @return */ public static ThemeConfig parseThemeAsset(Context context, String name) { InputStream inputStream = null; ThemeConfig themeConfig = null; try { inputStream = context.getResources().getAssets().open(name); if (inputStream == null) { return null; } XmlPullParser parser = Xml.newPullParser(); parser.setInput(inputStream, &quot;utf-8&quot;); int event = -1; while ((event = parser.next()) != XmlPullParser.END_DOCUMENT) { if (event != XmlPullParser.START_TAG) { continue; } String nodeTag = parser.getName(); if (ThemeConfig.NODE_COLORS.equals(nodeTag)) { themeConfig.colorList = parseConfigGroup(parser); } else if (ThemeConfig.NODE_DRAWABLES.equals(nodeTag)) { themeConfig.drawableList = parseConfigGroup(parser); } else if (ThemeConfig.NODE_STRINGS.equals(nodeTag)) { themeConfig.stringList = parseConfigGroup(parser); } else if (ThemeConfig.NODE_CUSTOM_VALUE.equals(nodeTag)) { themeConfig.customValueList = parseCustomValueGroup(parser); } else if (ThemeConfig.NODE_APPLY_COMMON_ATTRIBIUTE.equals(nodeTag)) { String value = parser.getAttributeValue(null, &quot;value&quot;); if (value != null &amp;&amp; value.equalsIgnoreCase(&quot;true&quot;)) { themeConfig.applyCommonAttrbiute = true; } else { themeConfig.applyCommonAttrbiute = false; } } else if (ThemeConfig.NODE_THEME_ROOT.equals(nodeTag)) { if (parser.getDepth() == 1) { themeConfig = new ThemeConfig(); } else { throw new Exception(&quot;ThemeRoot was in wrong place&quot;); } } } return themeConfig; } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } finally { // close input stream BaseStoreUtil.closeObject(inputStream); } return themeConfig; } 现在知道为什么ThemeConfig为什么这么多了吧，前面的常量都是用来解析xml的，也只有最后面几个变量是后来有用的。里面主要通过两个方法来解析，一个一个看看： /** * 解析ConfigItem 节点，转化为ConfigItem集合 * * @param parser * @return */ private static List&lt;ConfigItem&gt; parseConfigGroup(XmlPullParser parser) { if (parser == null || parser.getDepth() != 2) { return null; } int event = -1; int depth = parser.getDepth(); List&lt;ConfigItem&gt; itemList = new ArrayList&lt;ConfigItem&gt;(); ConfigItem configItem = null; try { while ((event = parser.next()) != XmlPullParser.END_TAG || (parser.getDepth() &gt; depth &amp;&amp; event != XmlPullParser.END_DOCUMENT)) { if (event != XmlPullParser.START_TAG) { continue; } String nodeTag = parser.getName(); if (ThemeConfig.NODE_CONFIG_ITEM.equals(nodeTag)) { configItem = new ConfigItem(); configItem.idName = parser.getAttributeValue(null, ThemeConfig.ATTR_VIEW_ID); if (parser.getAttributeCount() &gt;= 3) { MethodCall call = new MethodCall(); call.methodName = parser.getAttributeValue(null, ThemeConfig.ATTR_METHOD); call.resName = parser.getAttributeValue(null, ThemeConfig.ATTR_RES_NAME); call.special = parser.getAttributeValue(null, ThemeConfig.ATTR_SPECIAL_THEME); configItem.addMethodCall(call); } else { // parse method group configItem.addMethodCall(parseMethodCalls(parser)); } itemList.add(configItem); } } } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } return itemList; } 反射的过程就不再深究了，把对应的实体类也贴出来看看吧： public static class ConfigItem { public String idName; public List&lt;MethodCall&gt; methodCalls; public ConfigItem() { methodCalls = new ArrayList&lt;MethodCall&gt;(); } public void addMethodCall(MethodCall call) { methodCalls.add(call); } public void addMethodCall(List&lt;MethodCall&gt; calls) { methodCalls.addAll(calls); } } public static class MethodCall { public String methodName; public String resName; public String special; } 所以parseConfigGroup这个方法把xml配置的颜色，图片，文字都能解析出来，方法对应的JAVA对象中。后面还有一个customValueList是什么呢，这个和上面几个不太一样，前几个属性在xml配置后在java代码里面就不需要怎么操作了，而customValue不一样，它不会具体应用到某一个view上面，而是运行时把反射出来颜色图片等返回到java中让开发者自己处理，这一点很重要，因为我们配置的xml都是针对页面的，有些没有页面的地方（例如adpter）就需要使用customValue来处理主题元素。customValue是通过名为parseCustomValueGroup的方法解析的，来看看： private static List&lt;CustomValue&gt; parseCustomValueGroup(XmlPullParser parser) { if (parser == null || parser.getDepth() != 2) { return null; } int event = -1; int depth = parser.getDepth(); List&lt;CustomValue&gt; itemList = new ArrayList&lt;CustomValue&gt;(); CustomValue configItem = null; try { while ((event = parser.next()) != XmlPullParser.END_TAG || (parser.getDepth() &gt; depth &amp;&amp; event != XmlPullParser.END_DOCUMENT)) { if (event != XmlPullParser.START_TAG) { continue; } String nodeTag = parser.getName(); if (ThemeConfig.NODE_VALUE_DEF.equals(nodeTag)) { configItem = new CustomValue(); if (parser.getAttributeCount() &gt;= 2) { configItem.name = parser.getAttributeValue(null, ThemeConfig.ATTR_NAME); configItem.value = parser.getAttributeValue(null, ThemeConfig.ATTR_VALUE); configItem.type = parser.getAttributeValue(null, ThemeConfig.ATTR_TYPE); configItem.special = parser.getAttributeValue(null, ThemeConfig.ATTR_SPECIAL_THEME); } itemList.add(configItem); } } } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } return itemList; } public static class CustomValue { public String name; public String value; public String type; public String special; } 基本上也是大同小异啦。以上就是xml的解析了，当然只有解析肯定不够还有应用啦，回到apply方法里面，下面那个核心方法applyThemeConfig走起。 /** * 对所有类别的配置参数与对应的组件进行匹配 * * @param themeConfig * @throws Exception */ private void applyThemeConfig(ThemeConfig themeConfig) throws Exception { if (themeConfig == null) { return; } // colors List&lt;ConfigItem&gt; colorArray = themeConfig.colorList; if (colorArray != null &amp;&amp; colorArray.size() &gt; 0) { try { applyThemeColors(colorArray); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } // drawables List&lt;ConfigItem&gt; drawableArray = themeConfig.drawableList; if (drawableArray != null &amp;&amp; drawableArray.size() &gt; 0) { try { applyThemeDrawables(drawableArray); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } // strings List&lt;ConfigItem&gt; stringArray = themeConfig.stringList; if (stringArray != null &amp;&amp; stringArray.size() &gt; 0) { try { applyThemeStrings(stringArray); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } } 看上去简单清楚明了吧，把颜色图片字符串顺着应用一下就行了，当然怎么应用的，又要贴代码了： /** * 对color配置参数进行组件与参数的匹配组合 * * @param colorArray * @throws Exception */ private void applyThemeColors(List&lt;ConfigItem&gt; colorArray) throws Exception { applyConfigGroup(colorArray, new ApplyConfigListener() { @Override public void applyMethodCall(View view, MethodCall call) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { String methodName = call.methodName; String resName = call.resName; boolean isSpecial = false; try { isSpecial = Boolean.parseBoolean(call.special); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } int color = mSkinPackageManager.getThemeColor(resName, isSpecial); Method method = view.getClass().getMethod(methodName, new Class[] { int.class }); if (method == null) { return; } method.setAccessible(true); method.invoke(view, color); } }); } /** * 对drawable配置参数进行组件与参数的匹配组合 * * @param drawableArray * @throws Exception */ private void applyThemeDrawables(List&lt;ConfigItem&gt; drawableArray) throws Exception { applyConfigGroup(drawableArray, new ApplyConfigListener() { @Override public void applyMethodCall(View view, MethodCall call) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { String methodName = call.methodName; String resName = call.resName; boolean isSpecial = false; try { isSpecial = Boolean.parseBoolean(call.special); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } Drawable drawable = mSkinPackageManager.getThemeDrawable(resName, isSpecial); if (drawable == null) { return; } int paddingLeft = 0; int paddingTop = 0; int paddingRight = 0; int paddingBottom = 0; boolean needPaddingSet = drawable.getPadding(new Rect()); if (needPaddingSet) { paddingLeft = view.getPaddingLeft(); paddingTop = view.getPaddingTop(); paddingRight = view.getPaddingRight(); paddingBottom = view.getPaddingBottom(); if (paddingLeft == 0 &amp;&amp; paddingTop == 0 &amp;&amp; paddingRight == 0 &amp;&amp; paddingBottom == 0) { needPaddingSet = false; } } if (&quot;setBackgroundDrawable&quot;.equals(methodName)) { if (android.os.Build.VERSION.SDK_INT &gt;= 16) { methodName = &quot;setBackground&quot;; } } Method method = view.getClass().getMethod(methodName, new Class[] { Drawable.class }); if (method == null) { return; } method.setAccessible(true); method.invoke(view, drawable); if (needPaddingSet) { view.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom); } } }); } /** * 对string配置参数进行组件与参数的匹配组合 * * @param stringArray * @throws Exception */ private void applyThemeStrings(List&lt;ConfigItem&gt; stringArray) throws Exception { applyConfigGroup(stringArray, new ApplyConfigListener() { @Override public void applyMethodCall(View view, MethodCall call) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { String methodName = call.methodName; String resName = call.resName; String str = mSkinPackageManager.getThemeString(resName); if (str == null) { return; } Method method = view.getClass().getMethod(methodName, new Class[] { CharSequence.class }); if (method == null) { return; } method.setAccessible(true); method.invoke(view, str); } }); } 虽然这一块是整个代码结构的真正核心，但是好像看一下代码比一大堆废话来解释好很多，需要注意一下的是以上三个方法都调用了applyConfigGroup private void applyConfigGroup(List&lt;ConfigItem&gt; configList, ApplyConfigListener listener) { if (configList == null) { return; } for (int i = 0; i &lt; configList.size(); i++) { ConfigItem itemObject = configList.get(i); String idName = itemObject.idName; if (idName == null) { continue; } int viewId = getViewId(idName); if (viewId &lt;= 0) { Log.d(&quot;skin&quot;, &quot;applyConfigGroup: no viewId found name = &quot; + idName + &quot; skinConfigName = &quot; + skinConfigName); continue; } View view = rootView.findViewById(viewId); if (view == null) { Log.d(&quot;skin&quot;, &quot;applyConfigGroup: no view found viewId = &quot; + idName + &quot; skinConfigName = &quot; + skinConfigName); continue; } for (MethodCall call : itemObject.methodCalls) { try { listener.applyMethodCall(view, call); } catch (NoSuchMethodException e) { Log.w(&quot;wenba&quot;, e); } catch (IllegalAccessException e) { Log.w(&quot;wenba&quot;, e); } catch (IllegalArgumentException e) { Log.w(&quot;wenba&quot;, e); } catch (InvocationTargetException e) { Log.w(&quot;wenba&quot;, e); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } } } } 注意这里还有个监听器ApplyConfigListener： private static interface ApplyConfigListener { public void applyMethodCall(View view, MethodCall call) throws NoSuchMethodException, IllegalAccessException, IllegalArgumentException, InvocationTargetException; } 上面三块代码一起看比较能看出整体结构来，最后补上getViewId的代码: private int getViewId(String idName) { return context.getResources().getIdentifier(idName, &quot;id&quot;, context.getPackageName()); } 到目前为止就已经把关于更新主题的基本流程分析完了，比较偏向于原理，接下来看看从应用层的使用方法。 3.如何配置与使用主题还记得最开始的那个OtherActivity的截图吗，点击“设置成新主题”会执行如下代码： SkinPackageManager.getInstance(getApplicationContext()).loadSkin(&quot;SkinApple&quot;, new LoadSkinCallBack() { @Override public void loadSkinSuccess() { Log.d(&quot;kkkkkkkk&quot;, &quot;loadSkinSuccess&quot;); updateTheme(); } @Override public void loadSkinFail() { Log.d(&quot;kkkkkkkk&quot;, &quot;loadSkinFail&quot;); } }); 执行的是一个loadSkin方法，所以理所当然地看这个方法了： /** * 加载皮肤资源, 同步加载 * * @param dexPath * 需要加载的皮肤资源 * @param callback * 回调接口 */ public void loadSkin(String themeId, final LoadSkinCallBack callback) { // 当为默认皮肤时，加载本地资源 if (DEFAULT_THEME.equals(themeId)) { resetDefaultSkin(callback); return; } Resources resources = loadSkinById(themeId); if (resources != null) { curTheme = themeId; mResources = resources; if (callback != null) { callback.loadSkinSuccess(); } } else { if (callback != null) { callback.loadSkinFail(); } } } 如果themeId为默认的则执行resetDefaultSkin方法 public void resetDefaultSkin(LoadSkinCallBack callback) { Resources resources = mContext.getResources(); if (resources != null) { mResources = resources; curTheme = DEFAULT_THEME; SPSetting.saveAppSkinTheme(DEFAULT_THEME); if (callback != null) { callback.loadSkinSuccess(); } } else { if (callback != null) { callback.loadSkinFail(); } } } 其实主要就是拿对应的resources了，所以可以继续往下看，如果不是默认主题，那么会通过themeId来使用loadSkinById方法获得相应主题的Resources，是怎么获取到的呢，themeId又是什么鬼呢，继续看吧。 private Resources loadSkinById(String themeId) { Resources resources = null; String dexPath = loadSkinPackagePath(themeId); PackageInfo mInfo = getSkinPackageInfo(dexPath); if (mInfo == null) { return resources; } AssetManager assetManager; try { assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); addAssetPath.invoke(assetManager, dexPath); Resources superRes = mContext.getResources(); resources = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration()); } catch (Exception e) { Log.w(&quot;wenba&quot;, e); } return resources; } 如果你看过之前插件的那篇文章一定知道了，这个简直是异曲同工啊有木有，大概意思就是通过反射AssetManager的这个addAssetPath方法，把主题APK的路径注入进去，这样的assetManager生成的resources就可以在这个指定的路径下面去找资源文件了，所以loadSkinPackagePath大概也能猜出来是干啥的了。 /** * 获得皮肤资源的绝对路径 * * @param apkName * @return */ public String loadSkinPackagePath(final String skinId) { File dir = new File(themeRootPath); if (!dir.exists()) { dir.mkdirs(); } File[] apkFiles = dir.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { if (!pathname.isFile()) { return false; } if (!pathname.getName().startsWith(skinId)) { return false; } return true; } }); // load and delete old files if need if (apkFiles == null || apkFiles.length == 0) { return null; } if (apkFiles.length == 1) { return apkFiles[0].getName().matches(&quot;.*\\\\.apk&quot;) ? apkFiles[0].getAbsolutePath() : null; } else { int version = parseApkVersion(apkFiles[0].getName()); File target = apkFiles[0]; for (File file : apkFiles) { int flagVer = parseApkVersion(file.getName()); if (flagVer &gt; version) { version = flagVer; target.delete(); target = file; } } return target.getAbsolutePath(); } } 这个时候知道themeId是什么的吧，其实就是一个apk的前缀，通过这个前缀去找符合要求的apk，然后后面根据文件名判断找版本最高的返回： private int parseApkVersion(String name) { Pattern pattern = Pattern.compile(&quot;-(\\\\d+)\\\\.apk&quot;); Matcher matcher = pattern.matcher(name); if (matcher.find()) { String version = matcher.group(1); int verInt = 0; try { verInt = Integer.parseInt(version); } catch (Exception e) { // TODO: handle exception } return verInt; } return 0; } 返回到loadSkinById方法，dexPath算是初始化完成了，后面还有个getSkinPackageInfo方法，如果这个方法返回为空的话，就直接返回一个空的resources，就是明摆着不让用了哎。 private PackageInfo getSkinPackageInfo(String dexPath) { if (dexPath == null) { return null; } String sign = AppInfoUtils.getApkSignature(mContext, dexPath); String localSign = &quot;A6:08:A8:28:1A:BF:55:AF:A4:72:9A:F4:F6:34:06:CF:16:EF:BB:A2&quot;; if (sign == null || (localSign != null &amp;&amp; localSign.equals(sign))) {// 对主题包进行签名认证 PackageManager mPm = mContext.getPackageManager(); PackageInfo mInfo = mPm.getPackageArchiveInfo(dexPath, 0); return mInfo; } return null; } 原来是签名认证，有点意思了吧，获得apk的签名和合法的签名文件进行比对，如果是同一个就认证通过，不是的话就返回空了，虽然这样写也并不是很安全，但是的确是一种提醒。这个在APP开发，插件化开发中都具有重要意义，属于安全环节中不可缺少的一步了，安全无小事，切记切记。拿到了我们需要的resources，问题就迎刃而解了，先封装出去： public Resources getThemeResources() { if (mResources == null) { synchronized (this) { if (mResources == null) { mResources = mContext.getResources(); curTheme = DEFAULT_THEME; } } } return mResources; } 再随便来看一个，比如是图片： public Drawable getThemeDrawable(String drawableName, boolean isSpecial) { Resources resources = getThemeResources(isSpecial); int resId = getThemeResourceId(drawableName, &quot;drawable&quot;, isSpecial); if (resId &lt;= 0) { return null; } try { return resources.getDrawable(resId); } catch (OutOfMemoryError e) { Log.w(&quot;wenba&quot;, e); Log.e(&quot;skin&quot;, &quot;OutOfMemoryError: drawableName = &quot; + drawableName); } return null; } 然后就是各种反射调用设置方法了，到处原理性的介绍就到此为止了，原以为比起上两篇来说更简单，其实还是想多了，可能还是没有理太得太清，最好还是配合自己的想法和代码还原来看可能比较容易清楚。 ####4.使用实例补充从以上几个小节基本上也能大概猜出个该怎么使用的，还有些重要的东西没说，在这里补充一下，结合最开始介绍页面和id的地方 在assets–&gt;skin–&gt;config下面建立一个SkinApplyMainActivity，内容如下：```xml&lt;?xml version=”1.0” encoding=”utf-8”?&gt; 建立`OtherActivity`，内容如下： ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;ThemeRoot&gt; &lt;colors&gt; &lt;ConfigItem viewId=&quot;skin_default_theme_btn&quot; method=&quot;setBackgroundColor&quot; resName=&quot;theme&quot;/&gt; &lt;ConfigItem viewId=&quot;skin_new_theme_btn&quot; method=&quot;setTextColor&quot; resName=&quot;theme&quot;/&gt; &lt;/colors&gt; &lt;drawables&gt; &lt;ConfigItem viewId=&quot;root_layout&quot; method=&quot;setBackgroundDrawable&quot; resName=&quot;skin_main_bg&quot;/&gt; &lt;ConfigItem viewId=&quot;skin_other_img&quot; method=&quot;setBackgroundDrawable&quot; resName=&quot;skin_word_bg&quot;/&gt; &lt;/drawables&gt; &lt;CustomValue&gt; &lt;ValueDef name=&quot;skin_digits&quot; value=&quot;te_text_hint&quot; type=&quot;color&quot;/&gt; &lt;/CustomValue&gt; &lt;/ThemeRoot&gt; 最后来四张图说明一切：","tags":[{"name":"Android","slug":"Android","permalink":"http://same4869.github.io/tags/Android/"}]},{"title":"《精进：如何成为一个很厉害的人》读书笔记","date":"2017-02-10T16:00:00.000Z","path":"2017/02/11/精进/","text":"年轻人还是要多读书多思考，少刷头条和微博才是王道。 ———鲁迅 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;距离上一次写点非技术性东西已经是很久很久的事情了，最近很长一段时间都比较迷茫和痛苦信息的爆炸与碎片化，想尽一切办法想把既有的知识体系整理一番，当然这本身又是一个痛苦的过程。然而不断地做内心挣扎显然并无卵用，既然写作是一个梳理的方式，那就索性捡起来看看效果，还能输出一些分享，感觉也不错。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采铜老师的这本书已经出版了有一段时间了，目前豆瓣7.7，也算是鸡汤类图书中的高分书。两天的时间陆陆续续翻完，虽然还是不免俗套地套用了很多名人名言，名人传记，但是可以跳过去呀。里面也有一些东西跟之前的思考能产生共鸣，总的来说是一本值得少看几集电视剧去翻的书，不然过几天在车上就没电视剧看啦。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闲话说了不少，还没进入正题，这篇文章主要只把个人感觉有点意思或者有点共鸣的东西拿出来晒晒，如果想喝原味鸡汤的可以去看看书，个人觉得老是在说某某名人因为自律自强坚持不懈独立思考而成功这样的套路挺没意思了，好比大家中学时代被宫刑了无数次的司马迁。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;书里面阐述了我们日常时间的花费事件界定问题（“我们总是在重复地抓起沙子，把时间花在值得做的事情上”），简而言之也就是写代码和刷朋友圈区别在哪里。书中提出一个概念叫“半衰期”，就是跟物理学医学里面的那个类似。 ● 高收益值、长半衰期事情：找到真爱；学会一种有效的思想技巧；与“大牛”进行一场意味深长的说话；● 高收益值、短半衰期事情：买一件当季流行的衣服；玩一下午手机游戏；以“扶墙进、扶墙出”的方式吃一顿自助餐；● 低收益值、长半衰期事情：练一小时书法；背诵三首诗；读懂哲学著作的一个章节；多反复一组技能练习；认真地回复一封友人的邮件；● 低收益值、短半衰期事情：挑起或参与一次网络掐架；漫无目的地刷微博；运用社交软件窥视陌生人的隐私。 以上类似一个个篮子，可以把日常的一些不经意间花费时间的事情对号入座，然后心中谨记一个信条：尽可能做长半衰期的事情。这样是不是清晰一些了，就算是玩儿游戏想刷微博也知道自己在干什么，在做哪个篮子里的事情，还有哪个篮子是空的需要补补货了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再一个理论就是关于决策心理学的： 人在面临选择时，通常会采用“满意原则”，而不是“最优原则”。所谓满意原则，就是人会从自己最熟悉的待选项开始逐一进行考察，如果考察到一个满足内心标准的选项，就会采纳这个选项，余下的选项就废弃了，而并不是对比所有待选项，然后选出其中最好的。因此，一个人会不会做出一个尽量好的选择，跟他所采纳的标准有很大的关系。如果内心的标准比较低，那么很快就会找到一个满足标准的选项，而这个选项很可能在所有选项中并不优越；如果内心的标准比较高，那么就会多比较一些选项，最后选中的那个选项就会更好。 这个理论其实在中学的时候就看到过相似的，但是是针对男性的，大概意思是如果让男性和女性分别在一个有六层高的衣服专卖店去选衣服，一般女性要转完所有楼层才能选好中意的衣服，而男性一般都能在第一层就选好。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过书中的言论也比较赞同，为什么都在说环境影响人也是同样的道理，周围的环境决定能看到的一个目标高度，自然而然就成就了个人的高度。所谓为什么大家都在抢学区房，为什么大家都要考好学校，有时候想想也不单单是学校好吧，可能更多是进来的学生好，互相影响以至于看得更多想得更多目标更长远，这大概就是人和人不同的原因所在，所以眼界觉得思想，思想引导目标，目标决定高度。先不展开讨论了，这是一个没有边际又唉声叹气的话题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采铜老师在书中说了个案例，说有三个人去咨询他，分别是大二在校学生，刚入职的职员和在读博士，他们都遇到了不同程度的困扰，案例可以分享一下： 案例一：我从高一开始想学动画制作，大学的专业也想选这个，但是高考失利让我没有读上想读的专业，而是读了国际贸易。我现在大二，在顾及自己专业的同时还要去动画学院蹭课，同时还要搞社团，忙得一团糟，还感觉什么都没做好，同学都说我压力很大，但是我真的很迷茫，希望你能帮帮我！ 案例二：我是一个刚毕业的大学生，在一家公司做着无关痛痒的工作，我渴望去大城市展示自己的才华，尽管我没有什么才华可言。我想做一些有技术水准的工作，不停学习一些专业技能，我渴望到一个能用得到我所学知识的地方去，尽管我不专业。正是这种不专业让自己很没底气，没底气就没信心出去，突然发现我居然这么懦弱，或者说，自卑吧。 案例三：我是××大学的博士生，读博的过程非常痛苦，每天都在逃避，主要的原因是导师“放羊”和没有意义的指导以及对我的各种否定。这些耗尽了我的积极性。我自己什么也做不出，又找不到方向，越来越什么都不想做，天天只做自己喜欢的事情，实在不想在本专业继续下去，明白这样下去不是办法但又不知道该怎么改变，期望听到您对于读博过程的建议。 下面是以上整理出来图表： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里书上阐明了一个思维屏障，就是“隐含假设”。这是一种存在却不容易意识到的思维惯性，而这种东西却时时刻刻影响着我们。这就好比我们被几堵墙给围起来了而认为无路可走的时候，是因为我们本身存在一个“墙不能是路”的隐含假设中，不太容易意识到把墙打了走出去本身也是一种备选方案。所以来看看刚刚这个案例书里面挖掘出来的隐含假设：是不是有点意思，就像我们潜意思中认为的一些理所当然其实也可以拿来怀疑的，这是一种突破困境思考的不错的方法，并不是要强调怀疑所有东西，不然连一加一都怀疑了就没办法做好好做算术了。再提一下，知道了隐含假设的点就能从这些点上来各个分析突破了，所以以上案例解决方案的表格感觉没必要放上来，有兴趣可以自己去找找。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“精益创业”这个词是刚刚才听到的，不过这个模式是广大程序员熟悉得不能再熟悉得“敏捷开发”和“快速迭代”。因为身处互联网公司，所以类似的论调也非常耳濡目染。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记得前不久前跟公司的同事聊天，聊到公司去年的好久个产品都在短时间内经历了从风风火火到迅速死亡。同事就说这个是公司层面的问题了，一不能一味地听从老板，老板的一个想法就马上成立一个新项目，二不能太过重度化，要敏捷。老板的一句话之后，并不是马上成立新的项目组，然后搬迁的搬迁，招人的招人，把产品后端前端APP端市场运营销售甚至后勤人员都要重头配置一遍，一旦组建立得差不多几个月去过了，几个月对于一个身处互联网的公司意味着什么大家也都知道，然后又是几个月过去，一旦没做起来，又解散，又裁员，大家不欢而散。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以正确的姿势是“精益创业”里面提出的“最小化可行产品”，用最少的成本构建核心功能，快速投放到市场后进行快速迭代迅速修正。书中提出一种论调“你永远无法完全准备好”，所以不管是以上互联网公司的例子还是个人，都应该先主动去做一些尝试，得到一些反馈，在互动中再去完善，这也是想写这篇文章的另一个原因吧。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直想具象化自己的技能树，然后感觉在那个时候，应该就能很清楚该做什么和做的事对自己有什么影响，之前整理了很多笔记，分类归档，也深知现在大众错觉之一“收藏了感觉就掌握了”默默影响着一大批人，书中有个关于这个的论调： 是不是觉得我记下的这些东西，只是存放在那里，我依旧不知道怎么用？是不是觉得，我只是又积累了好多「资料」，然后安慰自己说，未来的某一天我总会用上它们？这些疑问对于教育心理学家来说已经司空见惯，他们一直在研究和反思这类学习模式——它被称为「直接传递模式」，即认为学习的过程就是简单、线性的「传递—接受」的过程，学习的目标只是用静态的知识把头脑装满。他们认为，更合理的模式应该是「建构主义」的模式，即学习者的知识不是简单地吸收而来，而是主动地建构而来，学习者必须充分地调用他们的已有知识，在一个主动性目标的指引下，在一个丰富的情境中，去探索甚至撞击那些新接触到的知识，在经过一系列复杂的交互之后，把这些知识纳入到原有的知识体系中。 这个真的只是方法论，属于“道理我都懂”类型的，感觉能做的也不过是多多注意新知识和旧知识的融会贯通，构建一个update之后的信息系统，这个融合过程书中称之为“解码”。“解码”也是有level的，书中例子讲到孩子家长和玩具工程师三者看“小黄鸭”这个玩具就会产生不同的解码。 在孩子眼中，他关心的是“小黄鸭说了什么”，于是他听到的是儿歌、故事。即孩子最关心的是最直接的信息。在家长眼中，他们关心的是“小黄鸭是什么”，首先他们会把它定义为一个玩具（而不是一只“鸭子”），然后他们可能会对这只鸭子的娱乐性、教育性、安全性、性价比等做出评判。也就是说，家长关心的是价值和意义。在玩具工程师眼中，他们关心的是“小黄鸭是怎么做出来的”，他们会思考和涉及小黄鸭有哪些功能模块，会想它的电路结构以及声光效果。也就是说，工程师关心的是结构和实现。 这种层层递增的东西也不言自明了，在用书中的话点个题： 求知的三个层级：信息、知识和技能。战五渣只接收信息，贪多求杂，泛泛之辈学习知识，以记住为要津，高手磨练技能，只求日日精进。 信息、知识和技能本不冲突，只不过技能是终点，前两者不过是迈向这个终点的路与桥。 ​​​​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;书中还有图像化信息，乔哈里窗格，杠铃策略这些东西，感觉写不下去了，不管是鸡汤还是方法论都是刚开始的时候很爽，到后来就觉得很烦很教条主义，所以只能跟大家说：的确是这样的。只是写个读书笔记而已，不管是从半衰期还是从对知识的消化层面，跟去看两集网剧差得也不多科科。","tags":[{"name":"个人随笔","slug":"个人随笔","permalink":"http://same4869.github.io/tags/个人随笔/"}]}]